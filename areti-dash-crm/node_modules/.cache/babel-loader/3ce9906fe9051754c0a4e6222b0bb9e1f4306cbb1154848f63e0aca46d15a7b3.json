{"ast":null,"code":"import Keycloak from 'keycloak-js';\nimport axios from 'axios';\n\n// Debugging helper\nfunction debugLog(...args) {\n  console.log('[Keycloak Debug]', ...args);\n}\n\n// Keycloak configuration\nconst keycloakConfig = {\n  url: 'http://localhost:8080',\n  realm: 'areti-alliance',\n  clientId: 'areti-crm-client'\n};\n\n// Singleton variables\nlet keycloak = null;\nlet initPromise = null;\n\n// Authentication service\nconst AuthService = {\n  // Initialize Keycloak with enhanced error handling\n  init: () => {\n    debugLog('Initializing Keycloak service');\n\n    // Return existing initialization promise if it exists\n    if (initPromise) {\n      debugLog('Using existing initialization promise');\n      return initPromise;\n    }\n\n    // Create Keycloak instance if it doesn't exist\n    if (!keycloak) {\n      debugLog('Creating new Keycloak instance');\n      try {\n        keycloak = new Keycloak(keycloakConfig);\n      } catch (error) {\n        debugLog('Error creating Keycloak instance:', error);\n        return Promise.reject(error);\n      }\n    }\n\n    // Create and store the initialization promise with enhanced error handling\n    initPromise = new Promise((resolve, reject) => {\n      try {\n        debugLog('Calling keycloak.init()');\n\n        // Use login-required for more reliable authentication\n        keycloak.init({\n          onLoad: 'login-required',\n          // Change to login-required for more reliable auth\n          silentCheckSsoRedirectUri: window.location.origin + '/silent-check-sso.html',\n          pkceMethod: 'S256',\n          enableLogging: true,\n          checkLoginIframe: false\n        }).then(authenticated => {\n          debugLog('Keycloak initialized, authenticated:', authenticated);\n          debugLog('Token exists:', !!keycloak.token);\n          if (authenticated && keycloak.token) {\n            debugLog('User is authenticated with valid token');\n\n            // Store basic info directly from token as a fallback\n            try {\n              var _keycloak$tokenParsed, _keycloak$tokenParsed2, _keycloak$tokenParsed3, _keycloak$tokenParsed4, _keycloak$tokenParsed5, _keycloak$tokenParsed6, _keycloak$tokenParsed7, _keycloak$tokenParsed8, _keycloak$tokenParsed9, _keycloak$tokenParsed10;\n              const basicUserInfo = {\n                name: ((_keycloak$tokenParsed = keycloak.tokenParsed) === null || _keycloak$tokenParsed === void 0 ? void 0 : _keycloak$tokenParsed.preferred_username) || ((_keycloak$tokenParsed2 = keycloak.tokenParsed) === null || _keycloak$tokenParsed2 === void 0 ? void 0 : _keycloak$tokenParsed2.name) || 'User',\n                email: ((_keycloak$tokenParsed3 = keycloak.tokenParsed) === null || _keycloak$tokenParsed3 === void 0 ? void 0 : _keycloak$tokenParsed3.email) || ((_keycloak$tokenParsed4 = keycloak.tokenParsed) === null || _keycloak$tokenParsed4 === void 0 ? void 0 : _keycloak$tokenParsed4.preferred_username) || 'user@example.com',\n                role: (_keycloak$tokenParsed5 = keycloak.tokenParsed) !== null && _keycloak$tokenParsed5 !== void 0 && (_keycloak$tokenParsed6 = _keycloak$tokenParsed5.realm_access) !== null && _keycloak$tokenParsed6 !== void 0 && (_keycloak$tokenParsed7 = _keycloak$tokenParsed6.roles) !== null && _keycloak$tokenParsed7 !== void 0 && _keycloak$tokenParsed7.includes('admin') ? 'admin' : (_keycloak$tokenParsed8 = keycloak.tokenParsed) !== null && _keycloak$tokenParsed8 !== void 0 && (_keycloak$tokenParsed9 = _keycloak$tokenParsed8.realm_access) !== null && _keycloak$tokenParsed9 !== void 0 && (_keycloak$tokenParsed10 = _keycloak$tokenParsed9.roles) !== null && _keycloak$tokenParsed10 !== void 0 && _keycloak$tokenParsed10.includes('manager') ? 'manager' : 'user',\n                token: keycloak.token,\n                timestamp: new Date().getTime()\n              };\n              localStorage.setItem('aretiUser_backup', JSON.stringify(basicUserInfo));\n              debugLog('Stored backup user info');\n\n              // Try token exchange\n              AuthService.exchangeToken().then(() => {\n                debugLog('Token exchange successful');\n                resolve(authenticated);\n              }).catch(err => {\n                debugLog('Token exchange error, but continuing with backup info:', err);\n                // Still resolve as authenticated even if token exchange fails\n                resolve(authenticated);\n              });\n            } catch (error) {\n              debugLog('Error extracting user info from token:', error);\n              // Even with an error, we're still authenticated\n              resolve(authenticated);\n            }\n          } else {\n            debugLog('User is not authenticated or token is missing');\n\n            // Check if we already have a backup user\n            const backupUser = localStorage.getItem('aretiUser_backup');\n            if (backupUser) {\n              debugLog('Found backup user info, using that instead');\n              resolve(true); // Resolve as authenticated so we don't redirect to login\n            } else {\n              debugLog('No backup user info, continuing as unauthenticated');\n              resolve(authenticated);\n            }\n          }\n        }).catch(error => {\n          debugLog('Keycloak init error:', error);\n\n          // Check if we can recover using backup user info\n          const backupUser = localStorage.getItem('aretiUser_backup');\n          if (backupUser) {\n            debugLog('Found backup user info, recovering from init error');\n            resolve(true); // Resolve as authenticated using backup\n          } else {\n            // Reset initPromise so we can try again\n            initPromise = null;\n            reject(error);\n          }\n        });\n      } catch (error) {\n        debugLog('Exception during Keycloak init:', error);\n        // Reset initPromise so we can try again\n        initPromise = null;\n        reject(error);\n      }\n    });\n    return initPromise;\n  },\n  // Log in with enhanced error handling\n  login: () => {\n    debugLog('Starting login process');\n    try {\n      // Reset state before login\n      AuthService.reset();\n\n      // Create new Keycloak instance for login\n      keycloak = new Keycloak(keycloakConfig);\n\n      // Use redirectUri to return to the current page after login\n      const currentPath = window.location.pathname;\n      keycloak.login({\n        redirectUri: window.location.origin + currentPath\n      });\n    } catch (error) {\n      debugLog('Error during login process:', error);\n      // Fallback to window location change\n      window.location.href = keycloakConfig.url + '/realms/' + keycloakConfig.realm + '/protocol/openid-connect/auth?client_id=' + keycloakConfig.clientId + '&redirect_uri=' + encodeURIComponent(window.location.href) + '&response_type=code';\n    }\n  },\n  // Log out with enhanced error handling\n  logout: () => {\n    debugLog('Logging out');\n\n    // Clear local tokens\n    localStorage.removeItem('aretiUser');\n    localStorage.removeItem('aretiUser_backup');\n\n    // Reset the initialization promise\n    initPromise = null;\n    try {\n      // Logout from Keycloak if instance exists\n      if (keycloak) {\n        const currentPath = window.location.pathname;\n        keycloak.logout({\n          redirectUri: window.location.origin + currentPath\n        });\n      } else {\n        // Fallback to window reload\n        window.location.reload();\n      }\n    } catch (error) {\n      debugLog('Error during logout:', error);\n      // Fallback to window reload\n      window.location.reload();\n    }\n  },\n  // Check if authenticated\n  isAuthenticated: () => {\n    // First try to use Keycloak's state\n    if (keycloak && keycloak.authenticated) {\n      debugLog('Keycloak indicates authenticated state');\n      return true;\n    }\n\n    // Then check for tokens in storage as fallback\n    const hasUser = !!localStorage.getItem('aretiUser');\n    const hasBackupUser = !!localStorage.getItem('aretiUser_backup');\n    debugLog('Checking authentication from storage:', {\n      hasUser,\n      hasBackupUser\n    });\n    return hasUser || hasBackupUser;\n  },\n  // Exchange Keycloak token for app session token\n  exchangeToken: async () => {\n    if (!keycloak || !keycloak.token) {\n      debugLog('No Keycloak instance or token for exchange');\n      throw new Error('No token available for exchange');\n    }\n    try {\n      debugLog('Starting token exchange');\n      const authServiceUrl = 'http://localhost:4000';\n      debugLog('Posting to auth service');\n      const response = await axios.post(`${authServiceUrl}/auth/token`, {\n        token: keycloak.token\n      });\n      debugLog('Auth service response received');\n      const {\n        token\n      } = response.data;\n      if (!token) {\n        throw new Error('No token received from auth service');\n      }\n      try {\n        // Parse token to get user info\n        const base64Url = token.split('.')[1];\n        const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');\n        const payload = JSON.parse(window.atob(base64));\n\n        // Store in localStorage\n        const userInfo = {\n          email: payload.email || 'user@example.com',\n          name: payload.name || 'User',\n          role: payload.role || 'user',\n          token: token,\n          timestamp: new Date().getTime()\n        };\n        debugLog('Storing user info in localStorage');\n        localStorage.setItem('aretiUser', JSON.stringify(userInfo));\n        return token;\n      } catch (error) {\n        debugLog('Error processing token:', error);\n        throw error;\n      }\n    } catch (error) {\n      debugLog('Token exchange error:', error);\n      if (error.response) {\n        debugLog('Error response:', error.response.status);\n      }\n      throw error;\n    }\n  },\n  // Get user profile with enhanced fallback\n  getUserProfile: () => {\n    // Try primary user info first\n    const user = localStorage.getItem('aretiUser');\n    debugLog('Getting user profile from localStorage:', user ? 'found' : 'not found');\n    if (user) {\n      try {\n        return JSON.parse(user);\n      } catch (error) {\n        debugLog('Error parsing user data:', error);\n        // Continue to backup\n      }\n    }\n\n    // Try backup user info next\n    const backupUser = localStorage.getItem('aretiUser_backup');\n    if (backupUser) {\n      try {\n        debugLog('Using backup user info');\n        return JSON.parse(backupUser);\n      } catch (error) {\n        debugLog('Error parsing backup user data:', error);\n      }\n    }\n\n    // Last resort: try to extract from Keycloak directly\n    if (keycloak && keycloak.tokenParsed) {\n      var _keycloak$tokenParsed11, _keycloak$tokenParsed12, _keycloak$tokenParsed13, _keycloak$tokenParsed14;\n      debugLog('Creating user profile from Keycloak token');\n      return {\n        name: keycloak.tokenParsed.preferred_username || keycloak.tokenParsed.name || 'User',\n        email: keycloak.tokenParsed.email || keycloak.tokenParsed.preferred_username || 'user@example.com',\n        role: (_keycloak$tokenParsed11 = keycloak.tokenParsed.realm_access) !== null && _keycloak$tokenParsed11 !== void 0 && (_keycloak$tokenParsed12 = _keycloak$tokenParsed11.roles) !== null && _keycloak$tokenParsed12 !== void 0 && _keycloak$tokenParsed12.includes('admin') ? 'admin' : (_keycloak$tokenParsed13 = keycloak.tokenParsed.realm_access) !== null && _keycloak$tokenParsed13 !== void 0 && (_keycloak$tokenParsed14 = _keycloak$tokenParsed13.roles) !== null && _keycloak$tokenParsed14 !== void 0 && _keycloak$tokenParsed14.includes('manager') ? 'manager' : 'user',\n        token: keycloak.token,\n        timestamp: new Date().getTime()\n      };\n    }\n\n    // Nothing found\n    return null;\n  },\n  // Check if token is valid with better error handling\n  hasValidToken: () => {\n    try {\n      // Try with primary user\n      const user = localStorage.getItem('aretiUser');\n      if (user) {\n        const userData = JSON.parse(user);\n        const now = new Date().getTime();\n        // Check if token is expired (24 hour validity)\n        const isValid = now - userData.timestamp < 24 * 60 * 60 * 1000;\n        debugLog('Primary token valid:', isValid);\n        if (isValid) return true;\n      }\n\n      // Try with backup user\n      const backupUser = localStorage.getItem('aretiUser_backup');\n      if (backupUser) {\n        const backupData = JSON.parse(backupUser);\n        const now = new Date().getTime();\n        // Check if token is expired (24 hour validity)\n        const isValid = now - backupData.timestamp < 24 * 60 * 60 * 1000;\n        debugLog('Backup token valid:', isValid);\n        return isValid;\n      }\n\n      // If we reach here, no valid token found\n      debugLog('No valid token found');\n      return false;\n    } catch (error) {\n      debugLog('Error checking token validity:', error);\n      return false;\n    }\n  },\n  // Get authorization header with fallback strategy\n  getAuthHeader: () => {\n    try {\n      // Try primary user first\n      const user = localStorage.getItem('aretiUser');\n      if (user) {\n        const userData = JSON.parse(user);\n        if (userData.token) {\n          return {\n            'Authorization': `Bearer ${userData.token}`\n          };\n        }\n      }\n\n      // Try backup user next\n      const backupUser = localStorage.getItem('aretiUser_backup');\n      if (backupUser) {\n        const backupData = JSON.parse(backupUser);\n        if (backupData.token) {\n          return {\n            'Authorization': `Bearer ${backupData.token}`\n          };\n        }\n      }\n\n      // Try Keycloak directly as last resort\n      if (keycloak && keycloak.token) {\n        return {\n          'Authorization': `Bearer ${keycloak.token}`\n        };\n      }\n\n      // Nothing found\n      debugLog('No auth header available');\n      return {};\n    } catch (error) {\n      debugLog('Error creating auth header:', error);\n      return {};\n    }\n  },\n  // Reset service state with error handling\n  reset: () => {\n    debugLog('Resetting AuthService state');\n    try {\n      keycloak = null;\n      initPromise = null;\n    } catch (error) {\n      debugLog('Error during reset:', error);\n    }\n  }\n};\nexport default AuthService;","map":{"version":3,"names":["Keycloak","axios","debugLog","args","console","log","keycloakConfig","url","realm","clientId","keycloak","initPromise","AuthService","init","error","Promise","reject","resolve","onLoad","silentCheckSsoRedirectUri","window","location","origin","pkceMethod","enableLogging","checkLoginIframe","then","authenticated","token","_keycloak$tokenParsed","_keycloak$tokenParsed2","_keycloak$tokenParsed3","_keycloak$tokenParsed4","_keycloak$tokenParsed5","_keycloak$tokenParsed6","_keycloak$tokenParsed7","_keycloak$tokenParsed8","_keycloak$tokenParsed9","_keycloak$tokenParsed10","basicUserInfo","name","tokenParsed","preferred_username","email","role","realm_access","roles","includes","timestamp","Date","getTime","localStorage","setItem","JSON","stringify","exchangeToken","catch","err","backupUser","getItem","login","reset","currentPath","pathname","redirectUri","href","encodeURIComponent","logout","removeItem","reload","isAuthenticated","hasUser","hasBackupUser","Error","authServiceUrl","response","post","data","base64Url","split","base64","replace","payload","parse","atob","userInfo","status","getUserProfile","user","_keycloak$tokenParsed11","_keycloak$tokenParsed12","_keycloak$tokenParsed13","_keycloak$tokenParsed14","hasValidToken","userData","now","isValid","backupData","getAuthHeader"],"sources":["C:/Users/Administrator/Desktop/aretialliance/areti-dash-crm/src/services/keycloak.js"],"sourcesContent":["import Keycloak from 'keycloak-js';\r\nimport axios from 'axios';\r\n\r\n// Debugging helper\r\nfunction debugLog(...args) {\r\n  console.log('[Keycloak Debug]', ...args);\r\n}\r\n\r\n// Keycloak configuration\r\nconst keycloakConfig = {\r\n  url: 'http://localhost:8080',\r\n  realm: 'areti-alliance',\r\n  clientId: 'areti-crm-client'\r\n};\r\n\r\n// Singleton variables\r\nlet keycloak = null;\r\nlet initPromise = null;\r\n\r\n// Authentication service\r\nconst AuthService = {\r\n  // Initialize Keycloak with enhanced error handling\r\n  init: () => {\r\n    debugLog('Initializing Keycloak service');\r\n    \r\n    // Return existing initialization promise if it exists\r\n    if (initPromise) {\r\n      debugLog('Using existing initialization promise');\r\n      return initPromise;\r\n    }\r\n    \r\n    // Create Keycloak instance if it doesn't exist\r\n    if (!keycloak) {\r\n      debugLog('Creating new Keycloak instance');\r\n      try {\r\n        keycloak = new Keycloak(keycloakConfig);\r\n      } catch (error) {\r\n        debugLog('Error creating Keycloak instance:', error);\r\n        return Promise.reject(error);\r\n      }\r\n    }\r\n    \r\n    // Create and store the initialization promise with enhanced error handling\r\n    initPromise = new Promise((resolve, reject) => {\r\n      try {\r\n        debugLog('Calling keycloak.init()');\r\n        \r\n        // Use login-required for more reliable authentication\r\n        keycloak.init({\r\n          onLoad: 'login-required', // Change to login-required for more reliable auth\r\n          silentCheckSsoRedirectUri: window.location.origin + '/silent-check-sso.html',\r\n          pkceMethod: 'S256',\r\n          enableLogging: true,\r\n          checkLoginIframe: false\r\n        })\r\n          .then(authenticated => {\r\n            debugLog('Keycloak initialized, authenticated:', authenticated);\r\n            debugLog('Token exists:', !!keycloak.token);\r\n            \r\n            if (authenticated && keycloak.token) {\r\n              debugLog('User is authenticated with valid token');\r\n              \r\n              // Store basic info directly from token as a fallback\r\n              try {\r\n                const basicUserInfo = {\r\n                  name: keycloak.tokenParsed?.preferred_username || keycloak.tokenParsed?.name || 'User',\r\n                  email: keycloak.tokenParsed?.email || keycloak.tokenParsed?.preferred_username || 'user@example.com',\r\n                  role: keycloak.tokenParsed?.realm_access?.roles?.includes('admin') ? 'admin' :\r\n                        keycloak.tokenParsed?.realm_access?.roles?.includes('manager') ? 'manager' : 'user',\r\n                  token: keycloak.token,\r\n                  timestamp: new Date().getTime()\r\n                };\r\n                \r\n                localStorage.setItem('aretiUser_backup', JSON.stringify(basicUserInfo));\r\n                debugLog('Stored backup user info');\r\n                \r\n                // Try token exchange\r\n                AuthService.exchangeToken()\r\n                  .then(() => {\r\n                    debugLog('Token exchange successful');\r\n                    resolve(authenticated);\r\n                  })\r\n                  .catch(err => {\r\n                    debugLog('Token exchange error, but continuing with backup info:', err);\r\n                    // Still resolve as authenticated even if token exchange fails\r\n                    resolve(authenticated);\r\n                  });\r\n              } catch (error) {\r\n                debugLog('Error extracting user info from token:', error);\r\n                // Even with an error, we're still authenticated\r\n                resolve(authenticated);\r\n              }\r\n            } else {\r\n              debugLog('User is not authenticated or token is missing');\r\n              \r\n              // Check if we already have a backup user\r\n              const backupUser = localStorage.getItem('aretiUser_backup');\r\n              if (backupUser) {\r\n                debugLog('Found backup user info, using that instead');\r\n                resolve(true); // Resolve as authenticated so we don't redirect to login\r\n              } else {\r\n                debugLog('No backup user info, continuing as unauthenticated');\r\n                resolve(authenticated);\r\n              }\r\n            }\r\n          })\r\n          .catch(error => {\r\n            debugLog('Keycloak init error:', error);\r\n            \r\n            // Check if we can recover using backup user info\r\n            const backupUser = localStorage.getItem('aretiUser_backup');\r\n            if (backupUser) {\r\n              debugLog('Found backup user info, recovering from init error');\r\n              resolve(true); // Resolve as authenticated using backup\r\n            } else {\r\n              // Reset initPromise so we can try again\r\n              initPromise = null;\r\n              reject(error);\r\n            }\r\n          });\r\n      } catch (error) {\r\n        debugLog('Exception during Keycloak init:', error);\r\n        // Reset initPromise so we can try again\r\n        initPromise = null;\r\n        reject(error);\r\n      }\r\n    });\r\n    \r\n    return initPromise;\r\n  },\r\n\r\n  // Log in with enhanced error handling\r\n  login: () => {\r\n    debugLog('Starting login process');\r\n    \r\n    try {\r\n      // Reset state before login\r\n      AuthService.reset();\r\n      \r\n      // Create new Keycloak instance for login\r\n      keycloak = new Keycloak(keycloakConfig);\r\n      \r\n      // Use redirectUri to return to the current page after login\r\n      const currentPath = window.location.pathname;\r\n      keycloak.login({\r\n        redirectUri: window.location.origin + currentPath\r\n      });\r\n    } catch (error) {\r\n      debugLog('Error during login process:', error);\r\n      // Fallback to window location change\r\n      window.location.href = keycloakConfig.url + '/realms/' + keycloakConfig.realm + \r\n                             '/protocol/openid-connect/auth?client_id=' + \r\n                             keycloakConfig.clientId + \r\n                             '&redirect_uri=' + encodeURIComponent(window.location.href) + \r\n                             '&response_type=code';\r\n    }\r\n  },\r\n\r\n  // Log out with enhanced error handling\r\n  logout: () => {\r\n    debugLog('Logging out');\r\n    \r\n    // Clear local tokens\r\n    localStorage.removeItem('aretiUser');\r\n    localStorage.removeItem('aretiUser_backup');\r\n    \r\n    // Reset the initialization promise\r\n    initPromise = null;\r\n    \r\n    try {\r\n      // Logout from Keycloak if instance exists\r\n      if (keycloak) {\r\n        const currentPath = window.location.pathname;\r\n        keycloak.logout({\r\n          redirectUri: window.location.origin + currentPath\r\n        });\r\n      } else {\r\n        // Fallback to window reload\r\n        window.location.reload();\r\n      }\r\n    } catch (error) {\r\n      debugLog('Error during logout:', error);\r\n      // Fallback to window reload\r\n      window.location.reload();\r\n    }\r\n  },\r\n\r\n  // Check if authenticated\r\n  isAuthenticated: () => {\r\n    // First try to use Keycloak's state\r\n    if (keycloak && keycloak.authenticated) {\r\n      debugLog('Keycloak indicates authenticated state');\r\n      return true;\r\n    }\r\n    \r\n    // Then check for tokens in storage as fallback\r\n    const hasUser = !!localStorage.getItem('aretiUser');\r\n    const hasBackupUser = !!localStorage.getItem('aretiUser_backup');\r\n    \r\n    debugLog('Checking authentication from storage:', { hasUser, hasBackupUser });\r\n    return hasUser || hasBackupUser;\r\n  },\r\n\r\n  // Exchange Keycloak token for app session token\r\n  exchangeToken: async () => {\r\n    if (!keycloak || !keycloak.token) {\r\n      debugLog('No Keycloak instance or token for exchange');\r\n      throw new Error('No token available for exchange');\r\n    }\r\n    \r\n    try {\r\n      debugLog('Starting token exchange');\r\n      const authServiceUrl = 'http://localhost:4000';\r\n      \r\n      debugLog('Posting to auth service');\r\n      const response = await axios.post(`${authServiceUrl}/auth/token`, {\r\n        token: keycloak.token\r\n      });\r\n      \r\n      debugLog('Auth service response received');\r\n      const { token } = response.data;\r\n      \r\n      if (!token) {\r\n        throw new Error('No token received from auth service');\r\n      }\r\n      \r\n      try {\r\n        // Parse token to get user info\r\n        const base64Url = token.split('.')[1];\r\n        const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');\r\n        const payload = JSON.parse(window.atob(base64));\r\n        \r\n        // Store in localStorage\r\n        const userInfo = {\r\n          email: payload.email || 'user@example.com',\r\n          name: payload.name || 'User',\r\n          role: payload.role || 'user',\r\n          token: token,\r\n          timestamp: new Date().getTime()\r\n        };\r\n        \r\n        debugLog('Storing user info in localStorage');\r\n        localStorage.setItem('aretiUser', JSON.stringify(userInfo));\r\n        \r\n        return token;\r\n      } catch (error) {\r\n        debugLog('Error processing token:', error);\r\n        throw error;\r\n      }\r\n    } catch (error) {\r\n      debugLog('Token exchange error:', error);\r\n      if (error.response) {\r\n        debugLog('Error response:', error.response.status);\r\n      }\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  // Get user profile with enhanced fallback\r\n  getUserProfile: () => {\r\n    // Try primary user info first\r\n    const user = localStorage.getItem('aretiUser');\r\n    debugLog('Getting user profile from localStorage:', user ? 'found' : 'not found');\r\n    \r\n    if (user) {\r\n      try {\r\n        return JSON.parse(user);\r\n      } catch (error) {\r\n        debugLog('Error parsing user data:', error);\r\n        // Continue to backup\r\n      }\r\n    }\r\n    \r\n    // Try backup user info next\r\n    const backupUser = localStorage.getItem('aretiUser_backup');\r\n    if (backupUser) {\r\n      try {\r\n        debugLog('Using backup user info');\r\n        return JSON.parse(backupUser);\r\n      } catch (error) {\r\n        debugLog('Error parsing backup user data:', error);\r\n      }\r\n    }\r\n    \r\n    // Last resort: try to extract from Keycloak directly\r\n    if (keycloak && keycloak.tokenParsed) {\r\n      debugLog('Creating user profile from Keycloak token');\r\n      return {\r\n        name: keycloak.tokenParsed.preferred_username || keycloak.tokenParsed.name || 'User',\r\n        email: keycloak.tokenParsed.email || keycloak.tokenParsed.preferred_username || 'user@example.com',\r\n        role: keycloak.tokenParsed.realm_access?.roles?.includes('admin') ? 'admin' :\r\n              keycloak.tokenParsed.realm_access?.roles?.includes('manager') ? 'manager' : 'user',\r\n        token: keycloak.token,\r\n        timestamp: new Date().getTime()\r\n      };\r\n    }\r\n    \r\n    // Nothing found\r\n    return null;\r\n  },\r\n\r\n  // Check if token is valid with better error handling\r\n  hasValidToken: () => {\r\n    try {\r\n      // Try with primary user\r\n      const user = localStorage.getItem('aretiUser');\r\n      if (user) {\r\n        const userData = JSON.parse(user);\r\n        const now = new Date().getTime();\r\n        // Check if token is expired (24 hour validity)\r\n        const isValid = now - userData.timestamp < 24 * 60 * 60 * 1000;\r\n        debugLog('Primary token valid:', isValid);\r\n        if (isValid) return true;\r\n      }\r\n      \r\n      // Try with backup user\r\n      const backupUser = localStorage.getItem('aretiUser_backup');\r\n      if (backupUser) {\r\n        const backupData = JSON.parse(backupUser);\r\n        const now = new Date().getTime();\r\n        // Check if token is expired (24 hour validity)\r\n        const isValid = now - backupData.timestamp < 24 * 60 * 60 * 1000;\r\n        debugLog('Backup token valid:', isValid);\r\n        return isValid;\r\n      }\r\n      \r\n      // If we reach here, no valid token found\r\n      debugLog('No valid token found');\r\n      return false;\r\n    } catch (error) {\r\n      debugLog('Error checking token validity:', error);\r\n      return false;\r\n    }\r\n  },\r\n\r\n  // Get authorization header with fallback strategy\r\n  getAuthHeader: () => {\r\n    try {\r\n      // Try primary user first\r\n      const user = localStorage.getItem('aretiUser');\r\n      if (user) {\r\n        const userData = JSON.parse(user);\r\n        if (userData.token) {\r\n          return {\r\n            'Authorization': `Bearer ${userData.token}`\r\n          };\r\n        }\r\n      }\r\n      \r\n      // Try backup user next\r\n      const backupUser = localStorage.getItem('aretiUser_backup');\r\n      if (backupUser) {\r\n        const backupData = JSON.parse(backupUser);\r\n        if (backupData.token) {\r\n          return {\r\n            'Authorization': `Bearer ${backupData.token}`\r\n          };\r\n        }\r\n      }\r\n      \r\n      // Try Keycloak directly as last resort\r\n      if (keycloak && keycloak.token) {\r\n        return {\r\n          'Authorization': `Bearer ${keycloak.token}`\r\n        };\r\n      }\r\n      \r\n      // Nothing found\r\n      debugLog('No auth header available');\r\n      return {};\r\n    } catch (error) {\r\n      debugLog('Error creating auth header:', error);\r\n      return {};\r\n    }\r\n  },\r\n  \r\n  // Reset service state with error handling\r\n  reset: () => {\r\n    debugLog('Resetting AuthService state');\r\n    try {\r\n      keycloak = null;\r\n      initPromise = null;\r\n    } catch (error) {\r\n      debugLog('Error during reset:', error);\r\n    }\r\n  }\r\n};\r\n\r\nexport default AuthService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}