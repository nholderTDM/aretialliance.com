{"ast":null,"code":"import Keycloak from 'keycloak-js';\nimport axios from 'axios';\n\n// Debugging helper\nfunction debugLog(...args) {\n  console.log('[Keycloak Debug]', ...args);\n}\n\n// Keycloak configuration\nconst keycloakConfig = {\n  url: 'http://localhost:8080',\n  realm: 'areti-alliance',\n  clientId: 'areti-crm-client'\n};\n\n// Create a singleton Keycloak instance\nlet keycloak = null;\nlet initPromise = null;\n\n// Authentication service\nconst AuthService = {\n  // Initialize Keycloak - implement as a singleton pattern\n  init: () => {\n    debugLog('Initializing Keycloak service');\n\n    // Return existing initialization promise if it exists\n    if (initPromise) {\n      debugLog('Using existing initialization promise');\n      return initPromise;\n    }\n\n    // Create Keycloak instance if it doesn't exist\n    if (!keycloak) {\n      debugLog('Creating new Keycloak instance');\n      keycloak = new Keycloak(keycloakConfig);\n    }\n\n    // Create and store the initialization promise\n    initPromise = new Promise((resolve, reject) => {\n      try {\n        debugLog('Calling keycloak.init()');\n        keycloak.init({\n          onLoad: 'check-sso',\n          silentCheckSsoRedirectUri: window.location.origin + '/silent-check-sso.html',\n          pkceMethod: 'S256',\n          enableLogging: true,\n          checkLoginIframe: false\n        }).then(authenticated => {\n          debugLog('Keycloak initialized, authenticated:', authenticated);\n          debugLog('Token exists:', !!keycloak.token);\n          if (authenticated) {\n            var _keycloak$tokenParsed, _keycloak$tokenParsed2, _keycloak$tokenParsed3, _keycloak$tokenParsed4;\n            debugLog('User is authenticated');\n\n            // Store basic info directly from token as a fallback\n            const basicUserInfo = {\n              name: keycloak.tokenParsed.preferred_username || keycloak.tokenParsed.name,\n              email: keycloak.tokenParsed.email || keycloak.tokenParsed.preferred_username,\n              role: (_keycloak$tokenParsed = keycloak.tokenParsed.realm_access) !== null && _keycloak$tokenParsed !== void 0 && (_keycloak$tokenParsed2 = _keycloak$tokenParsed.roles) !== null && _keycloak$tokenParsed2 !== void 0 && _keycloak$tokenParsed2.includes('admin') ? 'admin' : (_keycloak$tokenParsed3 = keycloak.tokenParsed.realm_access) !== null && _keycloak$tokenParsed3 !== void 0 && (_keycloak$tokenParsed4 = _keycloak$tokenParsed3.roles) !== null && _keycloak$tokenParsed4 !== void 0 && _keycloak$tokenParsed4.includes('manager') ? 'manager' : 'user',\n              token: keycloak.token,\n              timestamp: new Date().getTime()\n            };\n            localStorage.setItem('aretiUser_backup', JSON.stringify(basicUserInfo));\n            debugLog('Stored backup user info');\n\n            // Try token exchange\n            AuthService.exchangeToken().then(() => {\n              debugLog('Token exchange successful');\n              resolve(authenticated);\n            }).catch(err => {\n              debugLog('Token exchange error:', err);\n              // Still resolve as authenticated even if token exchange fails\n              resolve(authenticated);\n            });\n          } else {\n            debugLog('User is not authenticated');\n            resolve(authenticated);\n          }\n        }).catch(error => {\n          debugLog('Keycloak init error:', error);\n          // Reset initPromise so we can try again\n          initPromise = null;\n          reject(error);\n        });\n      } catch (error) {\n        debugLog('Exception during Keycloak init:', error);\n        // Reset initPromise so we can try again\n        initPromise = null;\n        reject(error);\n      }\n    });\n    return initPromise;\n  },\n  // Log in\n  login: () => {\n    debugLog('Starting login process');\n    if (!keycloak) {\n      debugLog('Creating new Keycloak instance for login');\n      keycloak = new Keycloak(keycloakConfig);\n    }\n    keycloak.login();\n  },\n  // Log out\n  logout: () => {\n    debugLog('Logging out');\n    // Clear local tokens\n    localStorage.removeItem('aretiUser');\n    localStorage.removeItem('aretiUser_backup');\n\n    // Reset the initialization promise\n    initPromise = null;\n\n    // Logout from Keycloak if instance exists\n    if (keycloak) {\n      keycloak.logout();\n    }\n  },\n  // Check if authenticated\n  isAuthenticated: () => {\n    if (!keycloak) {\n      debugLog('No Keycloak instance exists for auth check');\n      return false;\n    }\n    const hasToken = !!keycloak.token;\n    debugLog('Checking if authenticated:', hasToken);\n    return hasToken;\n  },\n  // Exchange Keycloak token for app session token\n  exchangeToken: async () => {\n    if (!keycloak || !keycloak.token) {\n      debugLog('No Keycloak instance or token for exchange');\n      throw new Error('No token available for exchange');\n    }\n    try {\n      debugLog('Starting token exchange');\n      const authServiceUrl = 'http://localhost:4000';\n      debugLog('Posting to auth service');\n      const response = await axios.post(`${authServiceUrl}/auth/token`, {\n        token: keycloak.token\n      });\n      debugLog('Auth service response received');\n      const {\n        token\n      } = response.data;\n\n      // Parse token to get user info\n      const base64Url = token.split('.')[1];\n      const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');\n      const payload = JSON.parse(window.atob(base64));\n\n      // Store in localStorage\n      const userInfo = {\n        email: payload.email,\n        name: payload.name,\n        role: payload.role,\n        token: token,\n        timestamp: new Date().getTime()\n      };\n      debugLog('Storing user info in localStorage');\n      localStorage.setItem('aretiUser', JSON.stringify(userInfo));\n      return token;\n    } catch (error) {\n      debugLog('Token exchange error:', error);\n      if (error.response) {\n        debugLog('Error response:', error.response.status);\n      }\n      throw error;\n    }\n  },\n  // Get user profile\n  getUserProfile: () => {\n    const user = localStorage.getItem('aretiUser');\n    debugLog('Getting user profile from localStorage:', user ? 'found' : 'not found');\n    if (!user) {\n      // Try backup\n      const backupUser = localStorage.getItem('aretiUser_backup');\n      if (backupUser) {\n        debugLog('Using backup user info');\n        return JSON.parse(backupUser);\n      }\n      return null;\n    }\n    return JSON.parse(user);\n  },\n  // Check if token is valid\n  hasValidToken: () => {\n    const user = localStorage.getItem('aretiUser');\n    if (!user) {\n      debugLog('No user in localStorage');\n      return false;\n    }\n    const userData = JSON.parse(user);\n    const now = new Date().getTime();\n    // Check if token is expired (24 hour validity)\n    const isValid = now - userData.timestamp < 24 * 60 * 60 * 1000;\n    debugLog('Token valid:', isValid);\n    return isValid;\n  },\n  // Get authorization header\n  getAuthHeader: () => {\n    const user = localStorage.getItem('aretiUser');\n    if (!user) {\n      debugLog('No user in localStorage for auth header');\n      return {};\n    }\n    const userData = JSON.parse(user);\n    return {\n      'Authorization': `Bearer ${userData.token}`\n    };\n  },\n  // Reset service state - useful for testing or recovering from errors\n  reset: () => {\n    debugLog('Resetting AuthService state');\n    keycloak = null;\n    initPromise = null;\n  }\n};\nexport default AuthService;","map":{"version":3,"names":["Keycloak","axios","debugLog","args","console","log","keycloakConfig","url","realm","clientId","keycloak","initPromise","AuthService","init","Promise","resolve","reject","onLoad","silentCheckSsoRedirectUri","window","location","origin","pkceMethod","enableLogging","checkLoginIframe","then","authenticated","token","_keycloak$tokenParsed","_keycloak$tokenParsed2","_keycloak$tokenParsed3","_keycloak$tokenParsed4","basicUserInfo","name","tokenParsed","preferred_username","email","role","realm_access","roles","includes","timestamp","Date","getTime","localStorage","setItem","JSON","stringify","exchangeToken","catch","err","error","login","logout","removeItem","isAuthenticated","hasToken","Error","authServiceUrl","response","post","data","base64Url","split","base64","replace","payload","parse","atob","userInfo","status","getUserProfile","user","getItem","backupUser","hasValidToken","userData","now","isValid","getAuthHeader","reset"],"sources":["C:/Users/Administrator/Desktop/aretialliance/areti-dash-crm/src/services/keycloak.js"],"sourcesContent":["import Keycloak from 'keycloak-js';\r\nimport axios from 'axios';\r\n\r\n// Debugging helper\r\nfunction debugLog(...args) {\r\n  console.log('[Keycloak Debug]', ...args);\r\n}\r\n\r\n// Keycloak configuration\r\nconst keycloakConfig = {\r\n  url: 'http://localhost:8080',\r\n  realm: 'areti-alliance',\r\n  clientId: 'areti-crm-client'\r\n};\r\n\r\n// Create a singleton Keycloak instance\r\nlet keycloak = null;\r\nlet initPromise = null;\r\n\r\n// Authentication service\r\nconst AuthService = {\r\n  // Initialize Keycloak - implement as a singleton pattern\r\n  init: () => {\r\n    debugLog('Initializing Keycloak service');\r\n    \r\n    // Return existing initialization promise if it exists\r\n    if (initPromise) {\r\n      debugLog('Using existing initialization promise');\r\n      return initPromise;\r\n    }\r\n    \r\n    // Create Keycloak instance if it doesn't exist\r\n    if (!keycloak) {\r\n      debugLog('Creating new Keycloak instance');\r\n      keycloak = new Keycloak(keycloakConfig);\r\n    }\r\n    \r\n    // Create and store the initialization promise\r\n    initPromise = new Promise((resolve, reject) => {\r\n      try {\r\n        debugLog('Calling keycloak.init()');\r\n        keycloak.init({\r\n          onLoad: 'check-sso',\r\n          silentCheckSsoRedirectUri: window.location.origin + '/silent-check-sso.html',\r\n          pkceMethod: 'S256',\r\n          enableLogging: true,\r\n          checkLoginIframe: false\r\n        })\r\n          .then(authenticated => {\r\n            debugLog('Keycloak initialized, authenticated:', authenticated);\r\n            debugLog('Token exists:', !!keycloak.token);\r\n            \r\n            if (authenticated) {\r\n              debugLog('User is authenticated');\r\n              \r\n              // Store basic info directly from token as a fallback\r\n              const basicUserInfo = {\r\n                name: keycloak.tokenParsed.preferred_username || keycloak.tokenParsed.name,\r\n                email: keycloak.tokenParsed.email || keycloak.tokenParsed.preferred_username,\r\n                role: keycloak.tokenParsed.realm_access?.roles?.includes('admin') ? 'admin' :\r\n                      keycloak.tokenParsed.realm_access?.roles?.includes('manager') ? 'manager' : 'user',\r\n                token: keycloak.token,\r\n                timestamp: new Date().getTime()\r\n              };\r\n              \r\n              localStorage.setItem('aretiUser_backup', JSON.stringify(basicUserInfo));\r\n              debugLog('Stored backup user info');\r\n              \r\n              // Try token exchange\r\n              AuthService.exchangeToken()\r\n                .then(() => {\r\n                  debugLog('Token exchange successful');\r\n                  resolve(authenticated);\r\n                })\r\n                .catch(err => {\r\n                  debugLog('Token exchange error:', err);\r\n                  // Still resolve as authenticated even if token exchange fails\r\n                  resolve(authenticated);\r\n                });\r\n            } else {\r\n              debugLog('User is not authenticated');\r\n              resolve(authenticated);\r\n            }\r\n          })\r\n          .catch(error => {\r\n            debugLog('Keycloak init error:', error);\r\n            // Reset initPromise so we can try again\r\n            initPromise = null;\r\n            reject(error);\r\n          });\r\n      } catch (error) {\r\n        debugLog('Exception during Keycloak init:', error);\r\n        // Reset initPromise so we can try again\r\n        initPromise = null;\r\n        reject(error);\r\n      }\r\n    });\r\n    \r\n    return initPromise;\r\n  },\r\n\r\n  // Log in\r\n  login: () => {\r\n    debugLog('Starting login process');\r\n    if (!keycloak) {\r\n      debugLog('Creating new Keycloak instance for login');\r\n      keycloak = new Keycloak(keycloakConfig);\r\n    }\r\n    keycloak.login();\r\n  },\r\n\r\n  // Log out\r\n  logout: () => {\r\n    debugLog('Logging out');\r\n    // Clear local tokens\r\n    localStorage.removeItem('aretiUser');\r\n    localStorage.removeItem('aretiUser_backup');\r\n    \r\n    // Reset the initialization promise\r\n    initPromise = null;\r\n    \r\n    // Logout from Keycloak if instance exists\r\n    if (keycloak) {\r\n      keycloak.logout();\r\n    }\r\n  },\r\n\r\n  // Check if authenticated\r\n  isAuthenticated: () => {\r\n    if (!keycloak) {\r\n      debugLog('No Keycloak instance exists for auth check');\r\n      return false;\r\n    }\r\n    \r\n    const hasToken = !!keycloak.token;\r\n    debugLog('Checking if authenticated:', hasToken);\r\n    return hasToken;\r\n  },\r\n\r\n  // Exchange Keycloak token for app session token\r\n  exchangeToken: async () => {\r\n    if (!keycloak || !keycloak.token) {\r\n      debugLog('No Keycloak instance or token for exchange');\r\n      throw new Error('No token available for exchange');\r\n    }\r\n    \r\n    try {\r\n      debugLog('Starting token exchange');\r\n      const authServiceUrl = 'http://localhost:4000';\r\n      \r\n      debugLog('Posting to auth service');\r\n      const response = await axios.post(`${authServiceUrl}/auth/token`, {\r\n        token: keycloak.token\r\n      });\r\n      \r\n      debugLog('Auth service response received');\r\n      const { token } = response.data;\r\n      \r\n      // Parse token to get user info\r\n      const base64Url = token.split('.')[1];\r\n      const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');\r\n      const payload = JSON.parse(window.atob(base64));\r\n      \r\n      // Store in localStorage\r\n      const userInfo = {\r\n        email: payload.email,\r\n        name: payload.name,\r\n        role: payload.role,\r\n        token: token,\r\n        timestamp: new Date().getTime()\r\n      };\r\n      \r\n      debugLog('Storing user info in localStorage');\r\n      localStorage.setItem('aretiUser', JSON.stringify(userInfo));\r\n      \r\n      return token;\r\n    } catch (error) {\r\n      debugLog('Token exchange error:', error);\r\n      if (error.response) {\r\n        debugLog('Error response:', error.response.status);\r\n      }\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  // Get user profile\r\n  getUserProfile: () => {\r\n    const user = localStorage.getItem('aretiUser');\r\n    debugLog('Getting user profile from localStorage:', user ? 'found' : 'not found');\r\n    \r\n    if (!user) {\r\n      // Try backup\r\n      const backupUser = localStorage.getItem('aretiUser_backup');\r\n      if (backupUser) {\r\n        debugLog('Using backup user info');\r\n        return JSON.parse(backupUser);\r\n      }\r\n      return null;\r\n    }\r\n    \r\n    return JSON.parse(user);\r\n  },\r\n\r\n  // Check if token is valid\r\n  hasValidToken: () => {\r\n    const user = localStorage.getItem('aretiUser');\r\n    if (!user) {\r\n      debugLog('No user in localStorage');\r\n      return false;\r\n    }\r\n    \r\n    const userData = JSON.parse(user);\r\n    const now = new Date().getTime();\r\n    // Check if token is expired (24 hour validity)\r\n    const isValid = now - userData.timestamp < 24 * 60 * 60 * 1000;\r\n    debugLog('Token valid:', isValid);\r\n    return isValid;\r\n  },\r\n\r\n  // Get authorization header\r\n  getAuthHeader: () => {\r\n    const user = localStorage.getItem('aretiUser');\r\n    if (!user) {\r\n      debugLog('No user in localStorage for auth header');\r\n      return {};\r\n    }\r\n    \r\n    const userData = JSON.parse(user);\r\n    return {\r\n      'Authorization': `Bearer ${userData.token}`\r\n    };\r\n  },\r\n  \r\n  // Reset service state - useful for testing or recovering from errors\r\n  reset: () => {\r\n    debugLog('Resetting AuthService state');\r\n    keycloak = null;\r\n    initPromise = null;\r\n  }\r\n};\r\n\r\nexport default AuthService;"],"mappings":"AAAA,OAAOA,QAAQ,MAAM,aAAa;AAClC,OAAOC,KAAK,MAAM,OAAO;;AAEzB;AACA,SAASC,QAAQA,CAAC,GAAGC,IAAI,EAAE;EACzBC,OAAO,CAACC,GAAG,CAAC,kBAAkB,EAAE,GAAGF,IAAI,CAAC;AAC1C;;AAEA;AACA,MAAMG,cAAc,GAAG;EACrBC,GAAG,EAAE,uBAAuB;EAC5BC,KAAK,EAAE,gBAAgB;EACvBC,QAAQ,EAAE;AACZ,CAAC;;AAED;AACA,IAAIC,QAAQ,GAAG,IAAI;AACnB,IAAIC,WAAW,GAAG,IAAI;;AAEtB;AACA,MAAMC,WAAW,GAAG;EAClB;EACAC,IAAI,EAAEA,CAAA,KAAM;IACVX,QAAQ,CAAC,+BAA+B,CAAC;;IAEzC;IACA,IAAIS,WAAW,EAAE;MACfT,QAAQ,CAAC,uCAAuC,CAAC;MACjD,OAAOS,WAAW;IACpB;;IAEA;IACA,IAAI,CAACD,QAAQ,EAAE;MACbR,QAAQ,CAAC,gCAAgC,CAAC;MAC1CQ,QAAQ,GAAG,IAAIV,QAAQ,CAACM,cAAc,CAAC;IACzC;;IAEA;IACAK,WAAW,GAAG,IAAIG,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MAC7C,IAAI;QACFd,QAAQ,CAAC,yBAAyB,CAAC;QACnCQ,QAAQ,CAACG,IAAI,CAAC;UACZI,MAAM,EAAE,WAAW;UACnBC,yBAAyB,EAAEC,MAAM,CAACC,QAAQ,CAACC,MAAM,GAAG,wBAAwB;UAC5EC,UAAU,EAAE,MAAM;UAClBC,aAAa,EAAE,IAAI;UACnBC,gBAAgB,EAAE;QACpB,CAAC,CAAC,CACCC,IAAI,CAACC,aAAa,IAAI;UACrBxB,QAAQ,CAAC,sCAAsC,EAAEwB,aAAa,CAAC;UAC/DxB,QAAQ,CAAC,eAAe,EAAE,CAAC,CAACQ,QAAQ,CAACiB,KAAK,CAAC;UAE3C,IAAID,aAAa,EAAE;YAAA,IAAAE,qBAAA,EAAAC,sBAAA,EAAAC,sBAAA,EAAAC,sBAAA;YACjB7B,QAAQ,CAAC,uBAAuB,CAAC;;YAEjC;YACA,MAAM8B,aAAa,GAAG;cACpBC,IAAI,EAAEvB,QAAQ,CAACwB,WAAW,CAACC,kBAAkB,IAAIzB,QAAQ,CAACwB,WAAW,CAACD,IAAI;cAC1EG,KAAK,EAAE1B,QAAQ,CAACwB,WAAW,CAACE,KAAK,IAAI1B,QAAQ,CAACwB,WAAW,CAACC,kBAAkB;cAC5EE,IAAI,EAAE,CAAAT,qBAAA,GAAAlB,QAAQ,CAACwB,WAAW,CAACI,YAAY,cAAAV,qBAAA,gBAAAC,sBAAA,GAAjCD,qBAAA,CAAmCW,KAAK,cAAAV,sBAAA,eAAxCA,sBAAA,CAA0CW,QAAQ,CAAC,OAAO,CAAC,GAAG,OAAO,GACrE,CAAAV,sBAAA,GAAApB,QAAQ,CAACwB,WAAW,CAACI,YAAY,cAAAR,sBAAA,gBAAAC,sBAAA,GAAjCD,sBAAA,CAAmCS,KAAK,cAAAR,sBAAA,eAAxCA,sBAAA,CAA0CS,QAAQ,CAAC,SAAS,CAAC,GAAG,SAAS,GAAG,MAAM;cACxFb,KAAK,EAAEjB,QAAQ,CAACiB,KAAK;cACrBc,SAAS,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,OAAO,CAAC;YAChC,CAAC;YAEDC,YAAY,CAACC,OAAO,CAAC,kBAAkB,EAAEC,IAAI,CAACC,SAAS,CAACf,aAAa,CAAC,CAAC;YACvE9B,QAAQ,CAAC,yBAAyB,CAAC;;YAEnC;YACAU,WAAW,CAACoC,aAAa,CAAC,CAAC,CACxBvB,IAAI,CAAC,MAAM;cACVvB,QAAQ,CAAC,2BAA2B,CAAC;cACrCa,OAAO,CAACW,aAAa,CAAC;YACxB,CAAC,CAAC,CACDuB,KAAK,CAACC,GAAG,IAAI;cACZhD,QAAQ,CAAC,uBAAuB,EAAEgD,GAAG,CAAC;cACtC;cACAnC,OAAO,CAACW,aAAa,CAAC;YACxB,CAAC,CAAC;UACN,CAAC,MAAM;YACLxB,QAAQ,CAAC,2BAA2B,CAAC;YACrCa,OAAO,CAACW,aAAa,CAAC;UACxB;QACF,CAAC,CAAC,CACDuB,KAAK,CAACE,KAAK,IAAI;UACdjD,QAAQ,CAAC,sBAAsB,EAAEiD,KAAK,CAAC;UACvC;UACAxC,WAAW,GAAG,IAAI;UAClBK,MAAM,CAACmC,KAAK,CAAC;QACf,CAAC,CAAC;MACN,CAAC,CAAC,OAAOA,KAAK,EAAE;QACdjD,QAAQ,CAAC,iCAAiC,EAAEiD,KAAK,CAAC;QAClD;QACAxC,WAAW,GAAG,IAAI;QAClBK,MAAM,CAACmC,KAAK,CAAC;MACf;IACF,CAAC,CAAC;IAEF,OAAOxC,WAAW;EACpB,CAAC;EAED;EACAyC,KAAK,EAAEA,CAAA,KAAM;IACXlD,QAAQ,CAAC,wBAAwB,CAAC;IAClC,IAAI,CAACQ,QAAQ,EAAE;MACbR,QAAQ,CAAC,0CAA0C,CAAC;MACpDQ,QAAQ,GAAG,IAAIV,QAAQ,CAACM,cAAc,CAAC;IACzC;IACAI,QAAQ,CAAC0C,KAAK,CAAC,CAAC;EAClB,CAAC;EAED;EACAC,MAAM,EAAEA,CAAA,KAAM;IACZnD,QAAQ,CAAC,aAAa,CAAC;IACvB;IACA0C,YAAY,CAACU,UAAU,CAAC,WAAW,CAAC;IACpCV,YAAY,CAACU,UAAU,CAAC,kBAAkB,CAAC;;IAE3C;IACA3C,WAAW,GAAG,IAAI;;IAElB;IACA,IAAID,QAAQ,EAAE;MACZA,QAAQ,CAAC2C,MAAM,CAAC,CAAC;IACnB;EACF,CAAC;EAED;EACAE,eAAe,EAAEA,CAAA,KAAM;IACrB,IAAI,CAAC7C,QAAQ,EAAE;MACbR,QAAQ,CAAC,4CAA4C,CAAC;MACtD,OAAO,KAAK;IACd;IAEA,MAAMsD,QAAQ,GAAG,CAAC,CAAC9C,QAAQ,CAACiB,KAAK;IACjCzB,QAAQ,CAAC,4BAA4B,EAAEsD,QAAQ,CAAC;IAChD,OAAOA,QAAQ;EACjB,CAAC;EAED;EACAR,aAAa,EAAE,MAAAA,CAAA,KAAY;IACzB,IAAI,CAACtC,QAAQ,IAAI,CAACA,QAAQ,CAACiB,KAAK,EAAE;MAChCzB,QAAQ,CAAC,4CAA4C,CAAC;MACtD,MAAM,IAAIuD,KAAK,CAAC,iCAAiC,CAAC;IACpD;IAEA,IAAI;MACFvD,QAAQ,CAAC,yBAAyB,CAAC;MACnC,MAAMwD,cAAc,GAAG,uBAAuB;MAE9CxD,QAAQ,CAAC,yBAAyB,CAAC;MACnC,MAAMyD,QAAQ,GAAG,MAAM1D,KAAK,CAAC2D,IAAI,CAAC,GAAGF,cAAc,aAAa,EAAE;QAChE/B,KAAK,EAAEjB,QAAQ,CAACiB;MAClB,CAAC,CAAC;MAEFzB,QAAQ,CAAC,gCAAgC,CAAC;MAC1C,MAAM;QAAEyB;MAAM,CAAC,GAAGgC,QAAQ,CAACE,IAAI;;MAE/B;MACA,MAAMC,SAAS,GAAGnC,KAAK,CAACoC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;MACrC,MAAMC,MAAM,GAAGF,SAAS,CAACG,OAAO,CAAC,IAAI,EAAE,GAAG,CAAC,CAACA,OAAO,CAAC,IAAI,EAAE,GAAG,CAAC;MAC9D,MAAMC,OAAO,GAAGpB,IAAI,CAACqB,KAAK,CAAChD,MAAM,CAACiD,IAAI,CAACJ,MAAM,CAAC,CAAC;;MAE/C;MACA,MAAMK,QAAQ,GAAG;QACfjC,KAAK,EAAE8B,OAAO,CAAC9B,KAAK;QACpBH,IAAI,EAAEiC,OAAO,CAACjC,IAAI;QAClBI,IAAI,EAAE6B,OAAO,CAAC7B,IAAI;QAClBV,KAAK,EAAEA,KAAK;QACZc,SAAS,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,OAAO,CAAC;MAChC,CAAC;MAEDzC,QAAQ,CAAC,mCAAmC,CAAC;MAC7C0C,YAAY,CAACC,OAAO,CAAC,WAAW,EAAEC,IAAI,CAACC,SAAS,CAACsB,QAAQ,CAAC,CAAC;MAE3D,OAAO1C,KAAK;IACd,CAAC,CAAC,OAAOwB,KAAK,EAAE;MACdjD,QAAQ,CAAC,uBAAuB,EAAEiD,KAAK,CAAC;MACxC,IAAIA,KAAK,CAACQ,QAAQ,EAAE;QAClBzD,QAAQ,CAAC,iBAAiB,EAAEiD,KAAK,CAACQ,QAAQ,CAACW,MAAM,CAAC;MACpD;MACA,MAAMnB,KAAK;IACb;EACF,CAAC;EAED;EACAoB,cAAc,EAAEA,CAAA,KAAM;IACpB,MAAMC,IAAI,GAAG5B,YAAY,CAAC6B,OAAO,CAAC,WAAW,CAAC;IAC9CvE,QAAQ,CAAC,yCAAyC,EAAEsE,IAAI,GAAG,OAAO,GAAG,WAAW,CAAC;IAEjF,IAAI,CAACA,IAAI,EAAE;MACT;MACA,MAAME,UAAU,GAAG9B,YAAY,CAAC6B,OAAO,CAAC,kBAAkB,CAAC;MAC3D,IAAIC,UAAU,EAAE;QACdxE,QAAQ,CAAC,wBAAwB,CAAC;QAClC,OAAO4C,IAAI,CAACqB,KAAK,CAACO,UAAU,CAAC;MAC/B;MACA,OAAO,IAAI;IACb;IAEA,OAAO5B,IAAI,CAACqB,KAAK,CAACK,IAAI,CAAC;EACzB,CAAC;EAED;EACAG,aAAa,EAAEA,CAAA,KAAM;IACnB,MAAMH,IAAI,GAAG5B,YAAY,CAAC6B,OAAO,CAAC,WAAW,CAAC;IAC9C,IAAI,CAACD,IAAI,EAAE;MACTtE,QAAQ,CAAC,yBAAyB,CAAC;MACnC,OAAO,KAAK;IACd;IAEA,MAAM0E,QAAQ,GAAG9B,IAAI,CAACqB,KAAK,CAACK,IAAI,CAAC;IACjC,MAAMK,GAAG,GAAG,IAAInC,IAAI,CAAC,CAAC,CAACC,OAAO,CAAC,CAAC;IAChC;IACA,MAAMmC,OAAO,GAAGD,GAAG,GAAGD,QAAQ,CAACnC,SAAS,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI;IAC9DvC,QAAQ,CAAC,cAAc,EAAE4E,OAAO,CAAC;IACjC,OAAOA,OAAO;EAChB,CAAC;EAED;EACAC,aAAa,EAAEA,CAAA,KAAM;IACnB,MAAMP,IAAI,GAAG5B,YAAY,CAAC6B,OAAO,CAAC,WAAW,CAAC;IAC9C,IAAI,CAACD,IAAI,EAAE;MACTtE,QAAQ,CAAC,yCAAyC,CAAC;MACnD,OAAO,CAAC,CAAC;IACX;IAEA,MAAM0E,QAAQ,GAAG9B,IAAI,CAACqB,KAAK,CAACK,IAAI,CAAC;IACjC,OAAO;MACL,eAAe,EAAE,UAAUI,QAAQ,CAACjD,KAAK;IAC3C,CAAC;EACH,CAAC;EAED;EACAqD,KAAK,EAAEA,CAAA,KAAM;IACX9E,QAAQ,CAAC,6BAA6B,CAAC;IACvCQ,QAAQ,GAAG,IAAI;IACfC,WAAW,GAAG,IAAI;EACpB;AACF,CAAC;AAED,eAAeC,WAAW","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}