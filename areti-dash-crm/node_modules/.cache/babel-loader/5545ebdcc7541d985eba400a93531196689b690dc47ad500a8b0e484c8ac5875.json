{"ast":null,"code":"import Keycloak from 'keycloak-js';\nimport axios from 'axios';\n\n// Debugging helper\nfunction debugLog(...args) {\n  console.log('[Keycloak Debug]', ...args);\n}\n\n// Keycloak configuration\nconst keycloakConfig = {\n  url: 'http://localhost:8080',\n  realm: 'areti-alliance',\n  clientId: 'areti-crm-client'\n};\n\n// Singleton variables\nlet keycloak = null;\nlet initPromise = null;\nlet initCount = 0; // Track initialization attempts to prevent loops\n\n// Authentication service\nconst AuthService = {\n  // Initialize Keycloak with loop prevention\n  init: () => {\n    debugLog('Initializing Keycloak service');\n\n    // Check for initialization count to prevent loops\n    initCount++;\n    if (initCount > 2) {\n      debugLog('Too many initialization attempts, possible loop detected');\n      // Try to recover from localStorage if possible\n      const backupUser = localStorage.getItem('aretiUser_backup');\n      if (backupUser) {\n        debugLog('Using backup user data to break the loop');\n        return Promise.resolve(true);\n      }\n\n      // Reset count but return failure\n      initCount = 0;\n      return Promise.reject(new Error('Authentication loop detected'));\n    }\n\n    // Return existing initialization promise if it exists\n    if (initPromise) {\n      debugLog('Using existing initialization promise');\n      return initPromise;\n    }\n\n    // Create Keycloak instance if it doesn't exist\n    if (!keycloak) {\n      debugLog('Creating new Keycloak instance');\n      try {\n        keycloak = new Keycloak(keycloakConfig);\n      } catch (error) {\n        debugLog('Error creating Keycloak instance:', error);\n        return Promise.reject(error);\n      }\n    }\n\n    // Create and store the initialization promise with loop prevention\n    initPromise = new Promise((resolve, reject) => {\n      try {\n        debugLog('Calling keycloak.init()');\n\n        // Use check-sso instead of login-required to prevent redirect loops\n        keycloak.init({\n          onLoad: 'check-sso',\n          // Changed back to check-sso to prevent loops\n          silentCheckSsoRedirectUri: window.location.origin + '/silent-check-sso.html',\n          pkceMethod: 'S256',\n          enableLogging: true,\n          checkLoginIframe: false\n        }).then(authenticated => {\n          debugLog('Keycloak initialized, authenticated:', authenticated);\n          debugLog('Token exists:', !!keycloak.token);\n\n          // Reset init counter on successful init\n          initCount = 0;\n          if (authenticated && keycloak.token) {\n            debugLog('User is authenticated with valid token');\n\n            // Store basic info directly from token as a fallback\n            try {\n              var _keycloak$tokenParsed, _keycloak$tokenParsed2, _keycloak$tokenParsed3, _keycloak$tokenParsed4, _keycloak$tokenParsed5, _keycloak$tokenParsed6, _keycloak$tokenParsed7, _keycloak$tokenParsed8, _keycloak$tokenParsed9, _keycloak$tokenParsed10;\n              const basicUserInfo = {\n                name: ((_keycloak$tokenParsed = keycloak.tokenParsed) === null || _keycloak$tokenParsed === void 0 ? void 0 : _keycloak$tokenParsed.preferred_username) || ((_keycloak$tokenParsed2 = keycloak.tokenParsed) === null || _keycloak$tokenParsed2 === void 0 ? void 0 : _keycloak$tokenParsed2.name) || 'User',\n                email: ((_keycloak$tokenParsed3 = keycloak.tokenParsed) === null || _keycloak$tokenParsed3 === void 0 ? void 0 : _keycloak$tokenParsed3.email) || ((_keycloak$tokenParsed4 = keycloak.tokenParsed) === null || _keycloak$tokenParsed4 === void 0 ? void 0 : _keycloak$tokenParsed4.preferred_username) || 'user@example.com',\n                role: (_keycloak$tokenParsed5 = keycloak.tokenParsed) !== null && _keycloak$tokenParsed5 !== void 0 && (_keycloak$tokenParsed6 = _keycloak$tokenParsed5.realm_access) !== null && _keycloak$tokenParsed6 !== void 0 && (_keycloak$tokenParsed7 = _keycloak$tokenParsed6.roles) !== null && _keycloak$tokenParsed7 !== void 0 && _keycloak$tokenParsed7.includes('admin') ? 'admin' : (_keycloak$tokenParsed8 = keycloak.tokenParsed) !== null && _keycloak$tokenParsed8 !== void 0 && (_keycloak$tokenParsed9 = _keycloak$tokenParsed8.realm_access) !== null && _keycloak$tokenParsed9 !== void 0 && (_keycloak$tokenParsed10 = _keycloak$tokenParsed9.roles) !== null && _keycloak$tokenParsed10 !== void 0 && _keycloak$tokenParsed10.includes('manager') ? 'manager' : 'user',\n                token: keycloak.token,\n                timestamp: new Date().getTime()\n              };\n              localStorage.setItem('aretiUser_backup', JSON.stringify(basicUserInfo));\n              debugLog('Stored backup user info');\n\n              // Try token exchange\n              AuthService.exchangeToken().then(() => {\n                debugLog('Token exchange successful');\n                resolve(authenticated);\n              }).catch(err => {\n                debugLog('Token exchange error, but continuing with backup info:', err);\n                // Still resolve as authenticated even if token exchange fails\n                resolve(authenticated);\n              });\n            } catch (error) {\n              debugLog('Error extracting user info from token:', error);\n              // Even with an error, we're still authenticated\n              resolve(authenticated);\n            }\n          } else {\n            debugLog('User is not authenticated or token is missing');\n\n            // Check if we already have a backup user\n            const backupUser = localStorage.getItem('aretiUser_backup');\n            if (backupUser) {\n              debugLog('Found backup user info, using that instead');\n              resolve(true); // Resolve as authenticated so we don't redirect to login\n            } else {\n              debugLog('No backup user info, continuing as unauthenticated');\n              resolve(authenticated);\n            }\n          }\n        }).catch(error => {\n          debugLog('Keycloak init error:', error);\n\n          // Reset init counter on error\n          initCount = 0;\n\n          // Check if we can recover using backup user info\n          const backupUser = localStorage.getItem('aretiUser_backup');\n          if (backupUser) {\n            debugLog('Found backup user info, recovering from init error');\n            resolve(true); // Resolve as authenticated using backup\n          } else {\n            // Reset initPromise so we can try again\n            initPromise = null;\n            reject(error);\n          }\n        });\n      } catch (error) {\n        debugLog('Exception during Keycloak init:', error);\n\n        // Reset init counter on error\n        initCount = 0;\n\n        // Reset initPromise so we can try again\n        initPromise = null;\n        reject(error);\n      }\n    });\n    return initPromise;\n  },\n  // Log in with manual redirect\n  login: () => {\n    debugLog('Starting login process');\n    try {\n      // Reset state before login\n      AuthService.reset();\n\n      // Create new Keycloak instance for login\n      keycloak = new Keycloak(keycloakConfig);\n\n      // Use redirectUri to return to the current page after login\n      const currentPath = window.location.pathname;\n      keycloak.login({\n        redirectUri: window.location.origin + currentPath\n      });\n    } catch (error) {\n      debugLog('Error during login process:', error);\n      // Fallback to window location change\n      window.location.href = keycloakConfig.url + '/realms/' + keycloakConfig.realm + '/protocol/openid-connect/auth?client_id=' + keycloakConfig.clientId + '&redirect_uri=' + encodeURIComponent(window.location.href) + '&response_type=code';\n    }\n  },\n  // Log out with enhanced error handling\n  logout: () => {\n    debugLog('Logging out');\n\n    // Clear local tokens\n    localStorage.removeItem('aretiUser');\n    localStorage.removeItem('aretiUser_backup');\n\n    // Reset the initialization state\n    initPromise = null;\n    initCount = 0;\n    try {\n      // Logout from Keycloak if instance exists\n      if (keycloak) {\n        const currentPath = window.location.pathname;\n        keycloak.logout({\n          redirectUri: window.location.origin + currentPath\n        });\n      } else {\n        // Fallback to window reload\n        window.location.reload();\n      }\n    } catch (error) {\n      debugLog('Error during logout:', error);\n      // Fallback to window reload\n      window.location.reload();\n    }\n  },\n  // Check if authenticated\n  isAuthenticated: () => {\n    // First try to use Keycloak's state\n    if (keycloak && keycloak.authenticated) {\n      debugLog('Keycloak indicates authenticated state');\n      return true;\n    }\n\n    // Then check for tokens in storage as fallback\n    const hasUser = !!localStorage.getItem('aretiUser');\n    const hasBackupUser = !!localStorage.getItem('aretiUser_backup');\n    debugLog('Checking authentication from storage:', {\n      hasUser,\n      hasBackupUser\n    });\n    return hasUser || hasBackupUser;\n  },\n  // Exchange Keycloak token for app session token\n  exchangeToken: async () => {\n    if (!keycloak || !keycloak.token) {\n      debugLog('No Keycloak instance or token for exchange');\n      throw new Error('No token available for exchange');\n    }\n    try {\n      debugLog('Starting token exchange');\n      const authServiceUrl = 'http://localhost:4000';\n      debugLog('Posting to auth service');\n      const response = await axios.post(`${authServiceUrl}/auth/token`, {\n        token: keycloak.token\n      });\n      debugLog('Auth service response received');\n      const {\n        token\n      } = response.data;\n      if (!token) {\n        throw new Error('No token received from auth service');\n      }\n      try {\n        // Parse token to get user info\n        const base64Url = token.split('.')[1];\n        const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');\n        const payload = JSON.parse(window.atob(base64));\n\n        // Store in localStorage\n        const userInfo = {\n          email: payload.email || 'user@example.com',\n          name: payload.name || 'User',\n          role: payload.role || 'user',\n          token: token,\n          timestamp: new Date().getTime()\n        };\n        debugLog('Storing user info in localStorage');\n        localStorage.setItem('aretiUser', JSON.stringify(userInfo));\n        return token;\n      } catch (error) {\n        debugLog('Error processing token:', error);\n        throw error;\n      }\n    } catch (error) {\n      debugLog('Token exchange error:', error);\n      if (error.response) {\n        debugLog('Error response:', error.response.status);\n      }\n      throw error;\n    }\n  },\n  // Get user profile with enhanced fallback\n  getUserProfile: () => {\n    // Try primary user info first\n    const user = localStorage.getItem('aretiUser');\n    debugLog('Getting user profile from localStorage:', user ? 'found' : 'not found');\n    if (user) {\n      try {\n        return JSON.parse(user);\n      } catch (error) {\n        debugLog('Error parsing user data:', error);\n        // Continue to backup\n      }\n    }\n\n    // Try backup user info next\n    const backupUser = localStorage.getItem('aretiUser_backup');\n    if (backupUser) {\n      try {\n        debugLog('Using backup user info');\n        return JSON.parse(backupUser);\n      } catch (error) {\n        debugLog('Error parsing backup user data:', error);\n      }\n    }\n\n    // Last resort: try to extract from Keycloak directly\n    if (keycloak && keycloak.tokenParsed) {\n      var _keycloak$tokenParsed11, _keycloak$tokenParsed12, _keycloak$tokenParsed13, _keycloak$tokenParsed14;\n      debugLog('Creating user profile from Keycloak token');\n      return {\n        name: keycloak.tokenParsed.preferred_username || keycloak.tokenParsed.name || 'User',\n        email: keycloak.tokenParsed.email || keycloak.tokenParsed.preferred_username || 'user@example.com',\n        role: (_keycloak$tokenParsed11 = keycloak.tokenParsed.realm_access) !== null && _keycloak$tokenParsed11 !== void 0 && (_keycloak$tokenParsed12 = _keycloak$tokenParsed11.roles) !== null && _keycloak$tokenParsed12 !== void 0 && _keycloak$tokenParsed12.includes('admin') ? 'admin' : (_keycloak$tokenParsed13 = keycloak.tokenParsed.realm_access) !== null && _keycloak$tokenParsed13 !== void 0 && (_keycloak$tokenParsed14 = _keycloak$tokenParsed13.roles) !== null && _keycloak$tokenParsed14 !== void 0 && _keycloak$tokenParsed14.includes('manager') ? 'manager' : 'user',\n        token: keycloak.token,\n        timestamp: new Date().getTime()\n      };\n    }\n\n    // Nothing found\n    return null;\n  },\n  // Check if token is valid with better error handling\n  hasValidToken: () => {\n    try {\n      // Try with primary user\n      const user = localStorage.getItem('aretiUser');\n      if (user) {\n        const userData = JSON.parse(user);\n        const now = new Date().getTime();\n        // Check if token is expired (24 hour validity)\n        const isValid = now - userData.timestamp < 24 * 60 * 60 * 1000;\n        debugLog('Primary token valid:', isValid);\n        if (isValid) return true;\n      }\n\n      // Try with backup user\n      const backupUser = localStorage.getItem('aretiUser_backup');\n      if (backupUser) {\n        const backupData = JSON.parse(backupUser);\n        const now = new Date().getTime();\n        // Check if token is expired (24 hour validity)\n        const isValid = now - backupData.timestamp < 24 * 60 * 60 * 1000;\n        debugLog('Backup token valid:', isValid);\n        return isValid;\n      }\n\n      // If we reach here, no valid token found\n      debugLog('No valid token found');\n      return false;\n    } catch (error) {\n      debugLog('Error checking token validity:', error);\n      return false;\n    }\n  },\n  // Get authorization header with fallback strategy\n  getAuthHeader: () => {\n    try {\n      // Try primary user first\n      const user = localStorage.getItem('aretiUser');\n      if (user) {\n        const userData = JSON.parse(user);\n        if (userData.token) {\n          return {\n            'Authorization': `Bearer ${userData.token}`\n          };\n        }\n      }\n\n      // Try backup user next\n      const backupUser = localStorage.getItem('aretiUser_backup');\n      if (backupUser) {\n        const backupData = JSON.parse(backupUser);\n        if (backupData.token) {\n          return {\n            'Authorization': `Bearer ${backupData.token}`\n          };\n        }\n      }\n\n      // Try Keycloak directly as last resort\n      if (keycloak && keycloak.token) {\n        return {\n          'Authorization': `Bearer ${keycloak.token}`\n        };\n      }\n\n      // Nothing found\n      debugLog('No auth header available');\n      return {};\n    } catch (error) {\n      debugLog('Error creating auth header:', error);\n      return {};\n    }\n  },\n  // Reset service state with error handling\n  reset: () => {\n    debugLog('Resetting AuthService state');\n    try {\n      keycloak = null;\n      initPromise = null;\n      initCount = 0;\n    } catch (error) {\n      debugLog('Error during reset:', error);\n    }\n  }\n};\nexport default AuthService;","map":{"version":3,"names":["Keycloak","axios","debugLog","args","console","log","keycloakConfig","url","realm","clientId","keycloak","initPromise","initCount","AuthService","init","backupUser","localStorage","getItem","Promise","resolve","reject","Error","error","onLoad","silentCheckSsoRedirectUri","window","location","origin","pkceMethod","enableLogging","checkLoginIframe","then","authenticated","token","_keycloak$tokenParsed","_keycloak$tokenParsed2","_keycloak$tokenParsed3","_keycloak$tokenParsed4","_keycloak$tokenParsed5","_keycloak$tokenParsed6","_keycloak$tokenParsed7","_keycloak$tokenParsed8","_keycloak$tokenParsed9","_keycloak$tokenParsed10","basicUserInfo","name","tokenParsed","preferred_username","email","role","realm_access","roles","includes","timestamp","Date","getTime","setItem","JSON","stringify","exchangeToken","catch","err","login","reset","currentPath","pathname","redirectUri","href","encodeURIComponent","logout","removeItem","reload","isAuthenticated","hasUser","hasBackupUser","authServiceUrl","response","post","data","base64Url","split","base64","replace","payload","parse","atob","userInfo","status","getUserProfile","user","_keycloak$tokenParsed11","_keycloak$tokenParsed12","_keycloak$tokenParsed13","_keycloak$tokenParsed14","hasValidToken","userData","now","isValid","backupData","getAuthHeader"],"sources":["C:/Users/Administrator/Desktop/aretialliance/areti-dash-crm/src/services/keycloak.js"],"sourcesContent":["import Keycloak from 'keycloak-js';\r\nimport axios from 'axios';\r\n\r\n// Debugging helper\r\nfunction debugLog(...args) {\r\n  console.log('[Keycloak Debug]', ...args);\r\n}\r\n\r\n// Keycloak configuration\r\nconst keycloakConfig = {\r\n  url: 'http://localhost:8080',\r\n  realm: 'areti-alliance',\r\n  clientId: 'areti-crm-client'\r\n};\r\n\r\n// Singleton variables\r\nlet keycloak = null;\r\nlet initPromise = null;\r\nlet initCount = 0; // Track initialization attempts to prevent loops\r\n\r\n// Authentication service\r\nconst AuthService = {\r\n  // Initialize Keycloak with loop prevention\r\n  init: () => {\r\n    debugLog('Initializing Keycloak service');\r\n    \r\n    // Check for initialization count to prevent loops\r\n    initCount++;\r\n    if (initCount > 2) {\r\n      debugLog('Too many initialization attempts, possible loop detected');\r\n      // Try to recover from localStorage if possible\r\n      const backupUser = localStorage.getItem('aretiUser_backup');\r\n      if (backupUser) {\r\n        debugLog('Using backup user data to break the loop');\r\n        return Promise.resolve(true);\r\n      }\r\n      \r\n      // Reset count but return failure\r\n      initCount = 0;\r\n      return Promise.reject(new Error('Authentication loop detected'));\r\n    }\r\n    \r\n    // Return existing initialization promise if it exists\r\n    if (initPromise) {\r\n      debugLog('Using existing initialization promise');\r\n      return initPromise;\r\n    }\r\n    \r\n    // Create Keycloak instance if it doesn't exist\r\n    if (!keycloak) {\r\n      debugLog('Creating new Keycloak instance');\r\n      try {\r\n        keycloak = new Keycloak(keycloakConfig);\r\n      } catch (error) {\r\n        debugLog('Error creating Keycloak instance:', error);\r\n        return Promise.reject(error);\r\n      }\r\n    }\r\n    \r\n    // Create and store the initialization promise with loop prevention\r\n    initPromise = new Promise((resolve, reject) => {\r\n      try {\r\n        debugLog('Calling keycloak.init()');\r\n        \r\n        // Use check-sso instead of login-required to prevent redirect loops\r\n        keycloak.init({\r\n          onLoad: 'check-sso', // Changed back to check-sso to prevent loops\r\n          silentCheckSsoRedirectUri: window.location.origin + '/silent-check-sso.html',\r\n          pkceMethod: 'S256',\r\n          enableLogging: true,\r\n          checkLoginIframe: false\r\n        })\r\n          .then(authenticated => {\r\n            debugLog('Keycloak initialized, authenticated:', authenticated);\r\n            debugLog('Token exists:', !!keycloak.token);\r\n            \r\n            // Reset init counter on successful init\r\n            initCount = 0;\r\n            \r\n            if (authenticated && keycloak.token) {\r\n              debugLog('User is authenticated with valid token');\r\n              \r\n              // Store basic info directly from token as a fallback\r\n              try {\r\n                const basicUserInfo = {\r\n                  name: keycloak.tokenParsed?.preferred_username || keycloak.tokenParsed?.name || 'User',\r\n                  email: keycloak.tokenParsed?.email || keycloak.tokenParsed?.preferred_username || 'user@example.com',\r\n                  role: keycloak.tokenParsed?.realm_access?.roles?.includes('admin') ? 'admin' :\r\n                        keycloak.tokenParsed?.realm_access?.roles?.includes('manager') ? 'manager' : 'user',\r\n                  token: keycloak.token,\r\n                  timestamp: new Date().getTime()\r\n                };\r\n                \r\n                localStorage.setItem('aretiUser_backup', JSON.stringify(basicUserInfo));\r\n                debugLog('Stored backup user info');\r\n                \r\n                // Try token exchange\r\n                AuthService.exchangeToken()\r\n                  .then(() => {\r\n                    debugLog('Token exchange successful');\r\n                    resolve(authenticated);\r\n                  })\r\n                  .catch(err => {\r\n                    debugLog('Token exchange error, but continuing with backup info:', err);\r\n                    // Still resolve as authenticated even if token exchange fails\r\n                    resolve(authenticated);\r\n                  });\r\n              } catch (error) {\r\n                debugLog('Error extracting user info from token:', error);\r\n                // Even with an error, we're still authenticated\r\n                resolve(authenticated);\r\n              }\r\n            } else {\r\n              debugLog('User is not authenticated or token is missing');\r\n              \r\n              // Check if we already have a backup user\r\n              const backupUser = localStorage.getItem('aretiUser_backup');\r\n              if (backupUser) {\r\n                debugLog('Found backup user info, using that instead');\r\n                resolve(true); // Resolve as authenticated so we don't redirect to login\r\n              } else {\r\n                debugLog('No backup user info, continuing as unauthenticated');\r\n                resolve(authenticated);\r\n              }\r\n            }\r\n          })\r\n          .catch(error => {\r\n            debugLog('Keycloak init error:', error);\r\n            \r\n            // Reset init counter on error\r\n            initCount = 0;\r\n            \r\n            // Check if we can recover using backup user info\r\n            const backupUser = localStorage.getItem('aretiUser_backup');\r\n            if (backupUser) {\r\n              debugLog('Found backup user info, recovering from init error');\r\n              resolve(true); // Resolve as authenticated using backup\r\n            } else {\r\n              // Reset initPromise so we can try again\r\n              initPromise = null;\r\n              reject(error);\r\n            }\r\n          });\r\n      } catch (error) {\r\n        debugLog('Exception during Keycloak init:', error);\r\n        \r\n        // Reset init counter on error\r\n        initCount = 0;\r\n        \r\n        // Reset initPromise so we can try again\r\n        initPromise = null;\r\n        reject(error);\r\n      }\r\n    });\r\n    \r\n    return initPromise;\r\n  },\r\n\r\n  // Log in with manual redirect\r\n  login: () => {\r\n    debugLog('Starting login process');\r\n    \r\n    try {\r\n      // Reset state before login\r\n      AuthService.reset();\r\n      \r\n      // Create new Keycloak instance for login\r\n      keycloak = new Keycloak(keycloakConfig);\r\n      \r\n      // Use redirectUri to return to the current page after login\r\n      const currentPath = window.location.pathname;\r\n      keycloak.login({\r\n        redirectUri: window.location.origin + currentPath\r\n      });\r\n    } catch (error) {\r\n      debugLog('Error during login process:', error);\r\n      // Fallback to window location change\r\n      window.location.href = keycloakConfig.url + '/realms/' + keycloakConfig.realm + \r\n                             '/protocol/openid-connect/auth?client_id=' + \r\n                             keycloakConfig.clientId + \r\n                             '&redirect_uri=' + encodeURIComponent(window.location.href) + \r\n                             '&response_type=code';\r\n    }\r\n  },\r\n\r\n  // Log out with enhanced error handling\r\n  logout: () => {\r\n    debugLog('Logging out');\r\n    \r\n    // Clear local tokens\r\n    localStorage.removeItem('aretiUser');\r\n    localStorage.removeItem('aretiUser_backup');\r\n    \r\n    // Reset the initialization state\r\n    initPromise = null;\r\n    initCount = 0;\r\n    \r\n    try {\r\n      // Logout from Keycloak if instance exists\r\n      if (keycloak) {\r\n        const currentPath = window.location.pathname;\r\n        keycloak.logout({\r\n          redirectUri: window.location.origin + currentPath\r\n        });\r\n      } else {\r\n        // Fallback to window reload\r\n        window.location.reload();\r\n      }\r\n    } catch (error) {\r\n      debugLog('Error during logout:', error);\r\n      // Fallback to window reload\r\n      window.location.reload();\r\n    }\r\n  },\r\n\r\n  // Check if authenticated\r\n  isAuthenticated: () => {\r\n    // First try to use Keycloak's state\r\n    if (keycloak && keycloak.authenticated) {\r\n      debugLog('Keycloak indicates authenticated state');\r\n      return true;\r\n    }\r\n    \r\n    // Then check for tokens in storage as fallback\r\n    const hasUser = !!localStorage.getItem('aretiUser');\r\n    const hasBackupUser = !!localStorage.getItem('aretiUser_backup');\r\n    \r\n    debugLog('Checking authentication from storage:', { hasUser, hasBackupUser });\r\n    return hasUser || hasBackupUser;\r\n  },\r\n\r\n  // Exchange Keycloak token for app session token\r\n  exchangeToken: async () => {\r\n    if (!keycloak || !keycloak.token) {\r\n      debugLog('No Keycloak instance or token for exchange');\r\n      throw new Error('No token available for exchange');\r\n    }\r\n    \r\n    try {\r\n      debugLog('Starting token exchange');\r\n      const authServiceUrl = 'http://localhost:4000';\r\n      \r\n      debugLog('Posting to auth service');\r\n      const response = await axios.post(`${authServiceUrl}/auth/token`, {\r\n        token: keycloak.token\r\n      });\r\n      \r\n      debugLog('Auth service response received');\r\n      const { token } = response.data;\r\n      \r\n      if (!token) {\r\n        throw new Error('No token received from auth service');\r\n      }\r\n      \r\n      try {\r\n        // Parse token to get user info\r\n        const base64Url = token.split('.')[1];\r\n        const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');\r\n        const payload = JSON.parse(window.atob(base64));\r\n        \r\n        // Store in localStorage\r\n        const userInfo = {\r\n          email: payload.email || 'user@example.com',\r\n          name: payload.name || 'User',\r\n          role: payload.role || 'user',\r\n          token: token,\r\n          timestamp: new Date().getTime()\r\n        };\r\n        \r\n        debugLog('Storing user info in localStorage');\r\n        localStorage.setItem('aretiUser', JSON.stringify(userInfo));\r\n        \r\n        return token;\r\n      } catch (error) {\r\n        debugLog('Error processing token:', error);\r\n        throw error;\r\n      }\r\n    } catch (error) {\r\n      debugLog('Token exchange error:', error);\r\n      if (error.response) {\r\n        debugLog('Error response:', error.response.status);\r\n      }\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  // Get user profile with enhanced fallback\r\n  getUserProfile: () => {\r\n    // Try primary user info first\r\n    const user = localStorage.getItem('aretiUser');\r\n    debugLog('Getting user profile from localStorage:', user ? 'found' : 'not found');\r\n    \r\n    if (user) {\r\n      try {\r\n        return JSON.parse(user);\r\n      } catch (error) {\r\n        debugLog('Error parsing user data:', error);\r\n        // Continue to backup\r\n      }\r\n    }\r\n    \r\n    // Try backup user info next\r\n    const backupUser = localStorage.getItem('aretiUser_backup');\r\n    if (backupUser) {\r\n      try {\r\n        debugLog('Using backup user info');\r\n        return JSON.parse(backupUser);\r\n      } catch (error) {\r\n        debugLog('Error parsing backup user data:', error);\r\n      }\r\n    }\r\n    \r\n    // Last resort: try to extract from Keycloak directly\r\n    if (keycloak && keycloak.tokenParsed) {\r\n      debugLog('Creating user profile from Keycloak token');\r\n      return {\r\n        name: keycloak.tokenParsed.preferred_username || keycloak.tokenParsed.name || 'User',\r\n        email: keycloak.tokenParsed.email || keycloak.tokenParsed.preferred_username || 'user@example.com',\r\n        role: keycloak.tokenParsed.realm_access?.roles?.includes('admin') ? 'admin' :\r\n              keycloak.tokenParsed.realm_access?.roles?.includes('manager') ? 'manager' : 'user',\r\n        token: keycloak.token,\r\n        timestamp: new Date().getTime()\r\n      };\r\n    }\r\n    \r\n    // Nothing found\r\n    return null;\r\n  },\r\n\r\n  // Check if token is valid with better error handling\r\n  hasValidToken: () => {\r\n    try {\r\n      // Try with primary user\r\n      const user = localStorage.getItem('aretiUser');\r\n      if (user) {\r\n        const userData = JSON.parse(user);\r\n        const now = new Date().getTime();\r\n        // Check if token is expired (24 hour validity)\r\n        const isValid = now - userData.timestamp < 24 * 60 * 60 * 1000;\r\n        debugLog('Primary token valid:', isValid);\r\n        if (isValid) return true;\r\n      }\r\n      \r\n      // Try with backup user\r\n      const backupUser = localStorage.getItem('aretiUser_backup');\r\n      if (backupUser) {\r\n        const backupData = JSON.parse(backupUser);\r\n        const now = new Date().getTime();\r\n        // Check if token is expired (24 hour validity)\r\n        const isValid = now - backupData.timestamp < 24 * 60 * 60 * 1000;\r\n        debugLog('Backup token valid:', isValid);\r\n        return isValid;\r\n      }\r\n      \r\n      // If we reach here, no valid token found\r\n      debugLog('No valid token found');\r\n      return false;\r\n    } catch (error) {\r\n      debugLog('Error checking token validity:', error);\r\n      return false;\r\n    }\r\n  },\r\n\r\n  // Get authorization header with fallback strategy\r\n  getAuthHeader: () => {\r\n    try {\r\n      // Try primary user first\r\n      const user = localStorage.getItem('aretiUser');\r\n      if (user) {\r\n        const userData = JSON.parse(user);\r\n        if (userData.token) {\r\n          return {\r\n            'Authorization': `Bearer ${userData.token}`\r\n          };\r\n        }\r\n      }\r\n      \r\n      // Try backup user next\r\n      const backupUser = localStorage.getItem('aretiUser_backup');\r\n      if (backupUser) {\r\n        const backupData = JSON.parse(backupUser);\r\n        if (backupData.token) {\r\n          return {\r\n            'Authorization': `Bearer ${backupData.token}`\r\n          };\r\n        }\r\n      }\r\n      \r\n      // Try Keycloak directly as last resort\r\n      if (keycloak && keycloak.token) {\r\n        return {\r\n          'Authorization': `Bearer ${keycloak.token}`\r\n        };\r\n      }\r\n      \r\n      // Nothing found\r\n      debugLog('No auth header available');\r\n      return {};\r\n    } catch (error) {\r\n      debugLog('Error creating auth header:', error);\r\n      return {};\r\n    }\r\n  },\r\n  \r\n  // Reset service state with error handling\r\n  reset: () => {\r\n    debugLog('Resetting AuthService state');\r\n    try {\r\n      keycloak = null;\r\n      initPromise = null;\r\n      initCount = 0;\r\n    } catch (error) {\r\n      debugLog('Error during reset:', error);\r\n    }\r\n  }\r\n};\r\n\r\nexport default AuthService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}