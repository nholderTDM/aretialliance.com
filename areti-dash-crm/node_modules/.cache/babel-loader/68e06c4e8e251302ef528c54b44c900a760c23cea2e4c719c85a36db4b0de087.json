{"ast":null,"code":"import Keycloak from 'keycloak-js';\nimport axios from 'axios';\n\n// Debugging helper\nfunction debugLog(...args) {\n  console.log('[Keycloak Debug]', ...args);\n}\n\n// Keycloak configuration\nconst keycloakConfig = {\n  url: 'http://localhost:8080',\n  realm: 'areti-alliance',\n  clientId: 'areti-crm-client'\n};\n\n// Track if Keycloak has been initialized\nlet keycloakInitialized = false;\nlet keycloak = null;\nlet initPromise = null;\n\n// Authentication service\nconst AuthService = {\n  // Initialize Keycloak - only once per page load\n  init: () => {\n    debugLog('Initializing Keycloak service');\n\n    // Return existing initialization promise if it exists\n    if (initPromise) {\n      debugLog('Using existing initialization promise');\n      return initPromise;\n    }\n\n    // If already initialized, create a resolved promise with the authentication state\n    if (keycloakInitialized) {\n      debugLog('Keycloak already initialized, returning current state');\n      return Promise.resolve(keycloak && keycloak.authenticated);\n    }\n\n    // Create Keycloak instance if it doesn't exist\n    if (!keycloak) {\n      debugLog('Creating new Keycloak instance');\n      try {\n        keycloak = new Keycloak(keycloakConfig);\n      } catch (error) {\n        debugLog('Error creating Keycloak instance:', error);\n        return Promise.reject(error);\n      }\n    }\n\n    // Create and store the initialization promise\n    initPromise = new Promise((resolve, reject) => {\n      try {\n        debugLog('Calling keycloak.init()');\n\n        // Use check-sso to prevent redirect loops\n        keycloak.init({\n          onLoad: 'check-sso',\n          silentCheckSsoRedirectUri: window.location.origin + '/silent-check-sso.html',\n          pkceMethod: 'S256',\n          enableLogging: true,\n          checkLoginIframe: false\n        }).then(authenticated => {\n          debugLog('Keycloak initialized, authenticated:', authenticated);\n          debugLog('Token exists:', !!keycloak.token);\n\n          // Mark as initialized to prevent duplicate init calls\n          keycloakInitialized = true;\n          if (authenticated && keycloak.token) {\n            debugLog('User is authenticated with valid token');\n\n            // Store basic info directly from token as a fallback\n            try {\n              var _keycloak$tokenParsed, _keycloak$tokenParsed2, _keycloak$tokenParsed3, _keycloak$tokenParsed4, _keycloak$tokenParsed5, _keycloak$tokenParsed6, _keycloak$tokenParsed7, _keycloak$tokenParsed8, _keycloak$tokenParsed9, _keycloak$tokenParsed10;\n              const basicUserInfo = {\n                name: ((_keycloak$tokenParsed = keycloak.tokenParsed) === null || _keycloak$tokenParsed === void 0 ? void 0 : _keycloak$tokenParsed.preferred_username) || ((_keycloak$tokenParsed2 = keycloak.tokenParsed) === null || _keycloak$tokenParsed2 === void 0 ? void 0 : _keycloak$tokenParsed2.name) || 'User',\n                email: ((_keycloak$tokenParsed3 = keycloak.tokenParsed) === null || _keycloak$tokenParsed3 === void 0 ? void 0 : _keycloak$tokenParsed3.email) || ((_keycloak$tokenParsed4 = keycloak.tokenParsed) === null || _keycloak$tokenParsed4 === void 0 ? void 0 : _keycloak$tokenParsed4.preferred_username) || 'user@example.com',\n                role: (_keycloak$tokenParsed5 = keycloak.tokenParsed) !== null && _keycloak$tokenParsed5 !== void 0 && (_keycloak$tokenParsed6 = _keycloak$tokenParsed5.realm_access) !== null && _keycloak$tokenParsed6 !== void 0 && (_keycloak$tokenParsed7 = _keycloak$tokenParsed6.roles) !== null && _keycloak$tokenParsed7 !== void 0 && _keycloak$tokenParsed7.includes('admin') ? 'admin' : (_keycloak$tokenParsed8 = keycloak.tokenParsed) !== null && _keycloak$tokenParsed8 !== void 0 && (_keycloak$tokenParsed9 = _keycloak$tokenParsed8.realm_access) !== null && _keycloak$tokenParsed9 !== void 0 && (_keycloak$tokenParsed10 = _keycloak$tokenParsed9.roles) !== null && _keycloak$tokenParsed10 !== void 0 && _keycloak$tokenParsed10.includes('manager') ? 'manager' : 'user',\n                token: keycloak.token,\n                timestamp: new Date().getTime()\n              };\n              localStorage.setItem('aretiUser_backup', JSON.stringify(basicUserInfo));\n              debugLog('Stored backup user info');\n\n              // Try token exchange\n              AuthService.exchangeToken().then(() => {\n                debugLog('Token exchange successful');\n                resolve(authenticated);\n              }).catch(err => {\n                debugLog('Token exchange error, but continuing with backup info:', err);\n                // Still resolve as authenticated even if token exchange fails\n                resolve(authenticated);\n              });\n            } catch (error) {\n              debugLog('Error extracting user info from token:', error);\n              // Even with an error, we're still authenticated\n              resolve(authenticated);\n            }\n          } else {\n            debugLog('User is not authenticated or token is missing');\n\n            // Check if we already have a backup user\n            const backupUser = localStorage.getItem('aretiUser_backup');\n            if (backupUser) {\n              debugLog('Found backup user info, using that instead');\n              resolve(true); // Resolve as authenticated so we don't redirect to login\n            } else {\n              debugLog('No backup user info, continuing as unauthenticated');\n              resolve(authenticated);\n            }\n          }\n        }).catch(error => {\n          debugLog('Keycloak init error:', error);\n\n          // Clear init promise so we can try again if needed\n          initPromise = null;\n\n          // Check if we can recover using backup user info\n          const backupUser = localStorage.getItem('aretiUser_backup');\n          if (backupUser) {\n            debugLog('Found backup user info, recovering from init error');\n            resolve(true); // Resolve as authenticated using backup\n          } else {\n            reject(error);\n          }\n        });\n      } catch (error) {\n        debugLog('Exception during Keycloak init:', error);\n\n        // Clear init promise so we can try again if needed\n        initPromise = null;\n        reject(error);\n      }\n    });\n    return initPromise;\n  },\n  // Log in\n  login: () => {\n    debugLog('Starting login process');\n    try {\n      // If no Keycloak instance exists, create one\n      if (!keycloak) {\n        debugLog('Creating new Keycloak instance for login');\n        keycloak = new Keycloak(keycloakConfig);\n      }\n\n      // Use redirectUri to return to the current page after login\n      const currentPath = window.location.pathname;\n      keycloak.login({\n        redirectUri: window.location.origin + currentPath\n      });\n    } catch (error) {\n      debugLog('Error during login process:', error);\n      // Fallback to window location change\n      window.location.href = keycloakConfig.url + '/realms/' + keycloakConfig.realm + '/protocol/openid-connect/auth?client_id=' + keycloakConfig.clientId + '&redirect_uri=' + encodeURIComponent(window.location.href) + '&response_type=code';\n    }\n  },\n  // Log out\n  logout: () => {\n    debugLog('Logging out');\n\n    // Clear local tokens\n    localStorage.removeItem('aretiUser');\n    localStorage.removeItem('aretiUser_backup');\n\n    // Reset initialization state\n    keycloakInitialized = false;\n    initPromise = null;\n    try {\n      // Logout from Keycloak if instance exists\n      if (keycloak) {\n        const currentPath = window.location.pathname;\n        keycloak.logout({\n          redirectUri: window.location.origin + currentPath\n        });\n      } else {\n        // Fallback to window reload\n        window.location.reload();\n      }\n    } catch (error) {\n      debugLog('Error during logout:', error);\n      // Fallback to window reload\n      window.location.reload();\n    }\n  },\n  // Check if authenticated\n  isAuthenticated: () => {\n    // First try to use Keycloak's state\n    if (keycloak && keycloak.authenticated) {\n      debugLog('Keycloak indicates authenticated state');\n      return true;\n    }\n\n    // Then check for tokens in storage as fallback\n    const hasUser = !!localStorage.getItem('aretiUser');\n    const hasBackupUser = !!localStorage.getItem('aretiUser_backup');\n    debugLog('Checking authentication from storage:', {\n      hasUser,\n      hasBackupUser\n    });\n    return hasUser || hasBackupUser;\n  },\n  // Exchange Keycloak token for app session token\n  exchangeToken: async () => {\n    if (!keycloak || !keycloak.token) {\n      debugLog('No Keycloak instance or token for exchange');\n      throw new Error('No token available for exchange');\n    }\n    try {\n      debugLog('Starting token exchange');\n      const authServiceUrl = 'http://localhost:4000';\n      debugLog('Posting to auth service');\n      const response = await axios.post(`${authServiceUrl}/auth/token`, {\n        token: keycloak.token\n      });\n      debugLog('Auth service response received');\n      const {\n        token\n      } = response.data;\n      if (!token) {\n        throw new Error('No token received from auth service');\n      }\n      try {\n        // Parse token to get user info\n        const base64Url = token.split('.')[1];\n        const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');\n        const payload = JSON.parse(window.atob(base64));\n\n        // Store in localStorage\n        const userInfo = {\n          email: payload.email || 'user@example.com',\n          name: payload.name || 'User',\n          role: payload.role || 'user',\n          token: token,\n          timestamp: new Date().getTime()\n        };\n        debugLog('Storing user info in localStorage');\n        localStorage.setItem('aretiUser', JSON.stringify(userInfo));\n        return token;\n      } catch (error) {\n        debugLog('Error processing token:', error);\n        throw error;\n      }\n    } catch (error) {\n      debugLog('Token exchange error:', error);\n      if (error.response) {\n        debugLog('Error response status:', error.response.status);\n      }\n      throw error;\n    }\n  },\n  // Get user profile with enhanced fallback\n  getUserProfile: () => {\n    // Try primary user info first\n    const user = localStorage.getItem('aretiUser');\n    debugLog('Getting user profile from localStorage:', user ? 'found' : 'not found');\n    if (user) {\n      try {\n        return JSON.parse(user);\n      } catch (error) {\n        debugLog('Error parsing user data:', error);\n        // Continue to backup\n      }\n    }\n\n    // Try backup user info next\n    const backupUser = localStorage.getItem('aretiUser_backup');\n    if (backupUser) {\n      try {\n        debugLog('Using backup user info');\n        return JSON.parse(backupUser);\n      } catch (error) {\n        debugLog('Error parsing backup user data:', error);\n      }\n    }\n\n    // Last resort: try to extract from Keycloak directly\n    if (keycloak && keycloak.tokenParsed) {\n      var _keycloak$tokenParsed11, _keycloak$tokenParsed12, _keycloak$tokenParsed13, _keycloak$tokenParsed14;\n      debugLog('Creating user profile from Keycloak token');\n      return {\n        name: keycloak.tokenParsed.preferred_username || keycloak.tokenParsed.name || 'User',\n        email: keycloak.tokenParsed.email || keycloak.tokenParsed.preferred_username || 'user@example.com',\n        role: (_keycloak$tokenParsed11 = keycloak.tokenParsed.realm_access) !== null && _keycloak$tokenParsed11 !== void 0 && (_keycloak$tokenParsed12 = _keycloak$tokenParsed11.roles) !== null && _keycloak$tokenParsed12 !== void 0 && _keycloak$tokenParsed12.includes('admin') ? 'admin' : (_keycloak$tokenParsed13 = keycloak.tokenParsed.realm_access) !== null && _keycloak$tokenParsed13 !== void 0 && (_keycloak$tokenParsed14 = _keycloak$tokenParsed13.roles) !== null && _keycloak$tokenParsed14 !== void 0 && _keycloak$tokenParsed14.includes('manager') ? 'manager' : 'user',\n        token: keycloak.token,\n        timestamp: new Date().getTime()\n      };\n    }\n\n    // Nothing found\n    return null;\n  },\n  // Check if token is valid\n  hasValidToken: () => {\n    try {\n      // Try with primary user\n      const user = localStorage.getItem('aretiUser');\n      if (user) {\n        const userData = JSON.parse(user);\n        const now = new Date().getTime();\n        // Check if token is expired (24 hour validity)\n        const isValid = now - userData.timestamp < 24 * 60 * 60 * 1000;\n        debugLog('Primary token valid:', isValid);\n        if (isValid) return true;\n      }\n\n      // Try with backup user\n      const backupUser = localStorage.getItem('aretiUser_backup');\n      if (backupUser) {\n        const backupData = JSON.parse(backupUser);\n        const now = new Date().getTime();\n        // Check if token is expired (24 hour validity)\n        const isValid = now - backupData.timestamp < 24 * 60 * 60 * 1000;\n        debugLog('Backup token valid:', isValid);\n        return isValid;\n      }\n\n      // If we reach here, no valid token found\n      debugLog('No valid token found');\n      return false;\n    } catch (error) {\n      debugLog('Error checking token validity:', error);\n      return false;\n    }\n  },\n  // Get authorization header with fallback strategy\n  getAuthHeader: () => {\n    try {\n      // Try primary user first\n      const user = localStorage.getItem('aretiUser');\n      if (user) {\n        const userData = JSON.parse(user);\n        if (userData.token) {\n          return {\n            'Authorization': `Bearer ${userData.token}`\n          };\n        }\n      }\n\n      // Try backup user next\n      const backupUser = localStorage.getItem('aretiUser_backup');\n      if (backupUser) {\n        const backupData = JSON.parse(backupUser);\n        if (backupData.token) {\n          return {\n            'Authorization': `Bearer ${backupData.token}`\n          };\n        }\n      }\n\n      // Try Keycloak directly as last resort\n      if (keycloak && keycloak.token) {\n        return {\n          'Authorization': `Bearer ${keycloak.token}`\n        };\n      }\n\n      // Nothing found\n      debugLog('No auth header available');\n      return {};\n    } catch (error) {\n      debugLog('Error creating auth header:', error);\n      return {};\n    }\n  },\n  // Reset service state\n  reset: () => {\n    debugLog('Resetting AuthService state');\n    keycloakInitialized = false;\n    keycloak = null;\n    initPromise = null;\n  }\n};\nexport default AuthService;","map":{"version":3,"names":["Keycloak","axios","debugLog","args","console","log","keycloakConfig","url","realm","clientId","keycloakInitialized","keycloak","initPromise","AuthService","init","Promise","resolve","authenticated","error","reject","onLoad","silentCheckSsoRedirectUri","window","location","origin","pkceMethod","enableLogging","checkLoginIframe","then","token","_keycloak$tokenParsed","_keycloak$tokenParsed2","_keycloak$tokenParsed3","_keycloak$tokenParsed4","_keycloak$tokenParsed5","_keycloak$tokenParsed6","_keycloak$tokenParsed7","_keycloak$tokenParsed8","_keycloak$tokenParsed9","_keycloak$tokenParsed10","basicUserInfo","name","tokenParsed","preferred_username","email","role","realm_access","roles","includes","timestamp","Date","getTime","localStorage","setItem","JSON","stringify","exchangeToken","catch","err","backupUser","getItem","login","currentPath","pathname","redirectUri","href","encodeURIComponent","logout","removeItem","reload","isAuthenticated","hasUser","hasBackupUser","Error","authServiceUrl","response","post","data","base64Url","split","base64","replace","payload","parse","atob","userInfo","status","getUserProfile","user","_keycloak$tokenParsed11","_keycloak$tokenParsed12","_keycloak$tokenParsed13","_keycloak$tokenParsed14","hasValidToken","userData","now","isValid","backupData","getAuthHeader","reset"],"sources":["C:/Users/Administrator/Desktop/aretialliance/areti-dash-crm/src/services/keycloak.js"],"sourcesContent":["import Keycloak from 'keycloak-js';\r\nimport axios from 'axios';\r\n\r\n// Debugging helper\r\nfunction debugLog(...args) {\r\n  console.log('[Keycloak Debug]', ...args);\r\n}\r\n\r\n// Keycloak configuration\r\nconst keycloakConfig = {\r\n  url: 'http://localhost:8080',\r\n  realm: 'areti-alliance',\r\n  clientId: 'areti-crm-client'\r\n};\r\n\r\n// Track if Keycloak has been initialized\r\nlet keycloakInitialized = false;\r\nlet keycloak = null;\r\nlet initPromise = null;\r\n\r\n// Authentication service\r\nconst AuthService = {\r\n  // Initialize Keycloak - only once per page load\r\n  init: () => {\r\n    debugLog('Initializing Keycloak service');\r\n    \r\n    // Return existing initialization promise if it exists\r\n    if (initPromise) {\r\n      debugLog('Using existing initialization promise');\r\n      return initPromise;\r\n    }\r\n    \r\n    // If already initialized, create a resolved promise with the authentication state\r\n    if (keycloakInitialized) {\r\n      debugLog('Keycloak already initialized, returning current state');\r\n      return Promise.resolve(keycloak && keycloak.authenticated);\r\n    }\r\n    \r\n    // Create Keycloak instance if it doesn't exist\r\n    if (!keycloak) {\r\n      debugLog('Creating new Keycloak instance');\r\n      try {\r\n        keycloak = new Keycloak(keycloakConfig);\r\n      } catch (error) {\r\n        debugLog('Error creating Keycloak instance:', error);\r\n        return Promise.reject(error);\r\n      }\r\n    }\r\n    \r\n    // Create and store the initialization promise\r\n    initPromise = new Promise((resolve, reject) => {\r\n      try {\r\n        debugLog('Calling keycloak.init()');\r\n        \r\n        // Use check-sso to prevent redirect loops\r\n        keycloak.init({\r\n          onLoad: 'check-sso',\r\n          silentCheckSsoRedirectUri: window.location.origin + '/silent-check-sso.html',\r\n          pkceMethod: 'S256',\r\n          enableLogging: true,\r\n          checkLoginIframe: false\r\n        })\r\n          .then(authenticated => {\r\n            debugLog('Keycloak initialized, authenticated:', authenticated);\r\n            debugLog('Token exists:', !!keycloak.token);\r\n            \r\n            // Mark as initialized to prevent duplicate init calls\r\n            keycloakInitialized = true;\r\n            \r\n            if (authenticated && keycloak.token) {\r\n              debugLog('User is authenticated with valid token');\r\n              \r\n              // Store basic info directly from token as a fallback\r\n              try {\r\n                const basicUserInfo = {\r\n                  name: keycloak.tokenParsed?.preferred_username || keycloak.tokenParsed?.name || 'User',\r\n                  email: keycloak.tokenParsed?.email || keycloak.tokenParsed?.preferred_username || 'user@example.com',\r\n                  role: keycloak.tokenParsed?.realm_access?.roles?.includes('admin') ? 'admin' :\r\n                        keycloak.tokenParsed?.realm_access?.roles?.includes('manager') ? 'manager' : 'user',\r\n                  token: keycloak.token,\r\n                  timestamp: new Date().getTime()\r\n                };\r\n                \r\n                localStorage.setItem('aretiUser_backup', JSON.stringify(basicUserInfo));\r\n                debugLog('Stored backup user info');\r\n                \r\n                // Try token exchange\r\n                AuthService.exchangeToken()\r\n                  .then(() => {\r\n                    debugLog('Token exchange successful');\r\n                    resolve(authenticated);\r\n                  })\r\n                  .catch(err => {\r\n                    debugLog('Token exchange error, but continuing with backup info:', err);\r\n                    // Still resolve as authenticated even if token exchange fails\r\n                    resolve(authenticated);\r\n                  });\r\n              } catch (error) {\r\n                debugLog('Error extracting user info from token:', error);\r\n                // Even with an error, we're still authenticated\r\n                resolve(authenticated);\r\n              }\r\n            } else {\r\n              debugLog('User is not authenticated or token is missing');\r\n              \r\n              // Check if we already have a backup user\r\n              const backupUser = localStorage.getItem('aretiUser_backup');\r\n              if (backupUser) {\r\n                debugLog('Found backup user info, using that instead');\r\n                resolve(true); // Resolve as authenticated so we don't redirect to login\r\n              } else {\r\n                debugLog('No backup user info, continuing as unauthenticated');\r\n                resolve(authenticated);\r\n              }\r\n            }\r\n          })\r\n          .catch(error => {\r\n            debugLog('Keycloak init error:', error);\r\n            \r\n            // Clear init promise so we can try again if needed\r\n            initPromise = null;\r\n            \r\n            // Check if we can recover using backup user info\r\n            const backupUser = localStorage.getItem('aretiUser_backup');\r\n            if (backupUser) {\r\n              debugLog('Found backup user info, recovering from init error');\r\n              resolve(true); // Resolve as authenticated using backup\r\n            } else {\r\n              reject(error);\r\n            }\r\n          });\r\n      } catch (error) {\r\n        debugLog('Exception during Keycloak init:', error);\r\n        \r\n        // Clear init promise so we can try again if needed\r\n        initPromise = null;\r\n        reject(error);\r\n      }\r\n    });\r\n    \r\n    return initPromise;\r\n  },\r\n\r\n  // Log in\r\n  login: () => {\r\n    debugLog('Starting login process');\r\n    \r\n    try {\r\n      // If no Keycloak instance exists, create one\r\n      if (!keycloak) {\r\n        debugLog('Creating new Keycloak instance for login');\r\n        keycloak = new Keycloak(keycloakConfig);\r\n      }\r\n      \r\n      // Use redirectUri to return to the current page after login\r\n      const currentPath = window.location.pathname;\r\n      keycloak.login({\r\n        redirectUri: window.location.origin + currentPath\r\n      });\r\n    } catch (error) {\r\n      debugLog('Error during login process:', error);\r\n      // Fallback to window location change\r\n      window.location.href = keycloakConfig.url + '/realms/' + keycloakConfig.realm + \r\n                             '/protocol/openid-connect/auth?client_id=' + \r\n                             keycloakConfig.clientId + \r\n                             '&redirect_uri=' + encodeURIComponent(window.location.href) + \r\n                             '&response_type=code';\r\n    }\r\n  },\r\n\r\n  // Log out\r\n  logout: () => {\r\n    debugLog('Logging out');\r\n    \r\n    // Clear local tokens\r\n    localStorage.removeItem('aretiUser');\r\n    localStorage.removeItem('aretiUser_backup');\r\n    \r\n    // Reset initialization state\r\n    keycloakInitialized = false;\r\n    initPromise = null;\r\n    \r\n    try {\r\n      // Logout from Keycloak if instance exists\r\n      if (keycloak) {\r\n        const currentPath = window.location.pathname;\r\n        keycloak.logout({\r\n          redirectUri: window.location.origin + currentPath\r\n        });\r\n      } else {\r\n        // Fallback to window reload\r\n        window.location.reload();\r\n      }\r\n    } catch (error) {\r\n      debugLog('Error during logout:', error);\r\n      // Fallback to window reload\r\n      window.location.reload();\r\n    }\r\n  },\r\n\r\n  // Check if authenticated\r\n  isAuthenticated: () => {\r\n    // First try to use Keycloak's state\r\n    if (keycloak && keycloak.authenticated) {\r\n      debugLog('Keycloak indicates authenticated state');\r\n      return true;\r\n    }\r\n    \r\n    // Then check for tokens in storage as fallback\r\n    const hasUser = !!localStorage.getItem('aretiUser');\r\n    const hasBackupUser = !!localStorage.getItem('aretiUser_backup');\r\n    \r\n    debugLog('Checking authentication from storage:', { hasUser, hasBackupUser });\r\n    return hasUser || hasBackupUser;\r\n  },\r\n\r\n  // Exchange Keycloak token for app session token\r\n  exchangeToken: async () => {\r\n    if (!keycloak || !keycloak.token) {\r\n      debugLog('No Keycloak instance or token for exchange');\r\n      throw new Error('No token available for exchange');\r\n    }\r\n    \r\n    try {\r\n      debugLog('Starting token exchange');\r\n      const authServiceUrl = 'http://localhost:4000';\r\n      \r\n      debugLog('Posting to auth service');\r\n      const response = await axios.post(`${authServiceUrl}/auth/token`, {\r\n        token: keycloak.token\r\n      });\r\n      \r\n      debugLog('Auth service response received');\r\n      const { token } = response.data;\r\n      \r\n      if (!token) {\r\n        throw new Error('No token received from auth service');\r\n      }\r\n      \r\n      try {\r\n        // Parse token to get user info\r\n        const base64Url = token.split('.')[1];\r\n        const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');\r\n        const payload = JSON.parse(window.atob(base64));\r\n        \r\n        // Store in localStorage\r\n        const userInfo = {\r\n          email: payload.email || 'user@example.com',\r\n          name: payload.name || 'User',\r\n          role: payload.role || 'user',\r\n          token: token,\r\n          timestamp: new Date().getTime()\r\n        };\r\n        \r\n        debugLog('Storing user info in localStorage');\r\n        localStorage.setItem('aretiUser', JSON.stringify(userInfo));\r\n        \r\n        return token;\r\n      } catch (error) {\r\n        debugLog('Error processing token:', error);\r\n        throw error;\r\n      }\r\n    } catch (error) {\r\n      debugLog('Token exchange error:', error);\r\n      if (error.response) {\r\n        debugLog('Error response status:', error.response.status);\r\n      }\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  // Get user profile with enhanced fallback\r\n  getUserProfile: () => {\r\n    // Try primary user info first\r\n    const user = localStorage.getItem('aretiUser');\r\n    debugLog('Getting user profile from localStorage:', user ? 'found' : 'not found');\r\n    \r\n    if (user) {\r\n      try {\r\n        return JSON.parse(user);\r\n      } catch (error) {\r\n        debugLog('Error parsing user data:', error);\r\n        // Continue to backup\r\n      }\r\n    }\r\n    \r\n    // Try backup user info next\r\n    const backupUser = localStorage.getItem('aretiUser_backup');\r\n    if (backupUser) {\r\n      try {\r\n        debugLog('Using backup user info');\r\n        return JSON.parse(backupUser);\r\n      } catch (error) {\r\n        debugLog('Error parsing backup user data:', error);\r\n      }\r\n    }\r\n    \r\n    // Last resort: try to extract from Keycloak directly\r\n    if (keycloak && keycloak.tokenParsed) {\r\n      debugLog('Creating user profile from Keycloak token');\r\n      return {\r\n        name: keycloak.tokenParsed.preferred_username || keycloak.tokenParsed.name || 'User',\r\n        email: keycloak.tokenParsed.email || keycloak.tokenParsed.preferred_username || 'user@example.com',\r\n        role: keycloak.tokenParsed.realm_access?.roles?.includes('admin') ? 'admin' :\r\n              keycloak.tokenParsed.realm_access?.roles?.includes('manager') ? 'manager' : 'user',\r\n        token: keycloak.token,\r\n        timestamp: new Date().getTime()\r\n      };\r\n    }\r\n    \r\n    // Nothing found\r\n    return null;\r\n  },\r\n\r\n  // Check if token is valid\r\n  hasValidToken: () => {\r\n    try {\r\n      // Try with primary user\r\n      const user = localStorage.getItem('aretiUser');\r\n      if (user) {\r\n        const userData = JSON.parse(user);\r\n        const now = new Date().getTime();\r\n        // Check if token is expired (24 hour validity)\r\n        const isValid = now - userData.timestamp < 24 * 60 * 60 * 1000;\r\n        debugLog('Primary token valid:', isValid);\r\n        if (isValid) return true;\r\n      }\r\n      \r\n      // Try with backup user\r\n      const backupUser = localStorage.getItem('aretiUser_backup');\r\n      if (backupUser) {\r\n        const backupData = JSON.parse(backupUser);\r\n        const now = new Date().getTime();\r\n        // Check if token is expired (24 hour validity)\r\n        const isValid = now - backupData.timestamp < 24 * 60 * 60 * 1000;\r\n        debugLog('Backup token valid:', isValid);\r\n        return isValid;\r\n      }\r\n      \r\n      // If we reach here, no valid token found\r\n      debugLog('No valid token found');\r\n      return false;\r\n    } catch (error) {\r\n      debugLog('Error checking token validity:', error);\r\n      return false;\r\n    }\r\n  },\r\n\r\n  // Get authorization header with fallback strategy\r\n  getAuthHeader: () => {\r\n    try {\r\n      // Try primary user first\r\n      const user = localStorage.getItem('aretiUser');\r\n      if (user) {\r\n        const userData = JSON.parse(user);\r\n        if (userData.token) {\r\n          return {\r\n            'Authorization': `Bearer ${userData.token}`\r\n          };\r\n        }\r\n      }\r\n      \r\n      // Try backup user next\r\n      const backupUser = localStorage.getItem('aretiUser_backup');\r\n      if (backupUser) {\r\n        const backupData = JSON.parse(backupUser);\r\n        if (backupData.token) {\r\n          return {\r\n            'Authorization': `Bearer ${backupData.token}`\r\n          };\r\n        }\r\n      }\r\n      \r\n      // Try Keycloak directly as last resort\r\n      if (keycloak && keycloak.token) {\r\n        return {\r\n          'Authorization': `Bearer ${keycloak.token}`\r\n        };\r\n      }\r\n      \r\n      // Nothing found\r\n      debugLog('No auth header available');\r\n      return {};\r\n    } catch (error) {\r\n      debugLog('Error creating auth header:', error);\r\n      return {};\r\n    }\r\n  },\r\n  \r\n  // Reset service state\r\n  reset: () => {\r\n    debugLog('Resetting AuthService state');\r\n    keycloakInitialized = false;\r\n    keycloak = null;\r\n    initPromise = null;\r\n  }\r\n};\r\n\r\nexport default AuthService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}